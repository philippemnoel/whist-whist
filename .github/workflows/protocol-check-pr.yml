# workflows/protocol-check-pr.yml
#
# Protocol: Check PR
# Checks a protocol PR for linting, clang standards and building success.

name: "Protocol: Check PR"

on:
    pull_request:
        branches:
            - prod
            - staging
            - dev
        paths:
            - "protocol/**"
            - "!protocol/README.md"
            - ".github/workflows/protocol-check-pr.yml"
            - "container-images/helper-scripts/copy_protocol_build.sh"
    workflow_dispatch:

jobs:
    # protocol-check-pr-building-linting:
    #     name: ${{ matrix.config.name }}
    #     runs-on: ${{ matrix.config.os }}

    #     # Platforms to build on/for
    #     strategy:
    #         matrix:
    #             config:
    #                 - name: "Build and Check Protocol on Windows (cl)"
    #                   os: windows-2019 # llvm, cmake, clang-tidy are pre-installed on windows-2019+ GHA machines
    #                   cuda: false # Set to true to CUDA-optimize the windows server executable. Note that CUDA takes 5-7min to install.
    #                 - name: "Build and Check Protocol on Linux Ubuntu (gcc)"
    #                   os: ubuntu-20.04 # cmake is pre-installed on ubuntu-18.04+ machines
    #                 - name: "Build and Check Protocol on macOS (clang)"
    #                   os: macos-10.14 # cmake is pre-installed on macos-10.14+ machines

    #     steps:
    #         - name: Checkout Git Repository
    #           uses: actions/checkout@v2

    #         # Necessary for downloading protocol libs and base Dockerfile NVIDIA GRID drivers from AWS S3
    #         - name: Configure AWS S3 CLI
    #           uses: aws-actions/configure-aws-credentials@v1
    #           with:
    #               aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
    #               aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
    #               aws-region: us-east-1

    #         ############################# Windows Configuration Steps START #############################

    #         - name: Install Chocolatey dependencies on Windows GHA Machine
    #           if: runner.os == 'Windows'
    #           uses: crazy-max/ghaction-chocolatey@v1
    #           with:
    #               args: install cppcheck ninja

    #         - name: Set up Visual Studio Developer Command Prompt (for nmake) on Windows GHA Machine
    #           if: runner.os == 'Windows'
    #           uses: ilammy/msvc-dev-cmd@v1

    #         - name: Install CUDA on Windows GHA Machine
    #           if: runner.os == 'Windows' && matrix.config.cuda
    #           env:
    #               visual_studio: "Visual Studio 16 2019" # Imported from env in the .ps1 script
    #               cuda: "11.0.167" # Imported from env in the .ps1 script, we use CUDA 11.0
    #           shell: powershell
    #           working-directory: .github\workflows\helpers\protocol
    #           run: |
    #               .\install_cuda_windows.ps1

    #               if ($?) {
    #                 # Set paths for subsequent steps, using $env:CUDA_PATH
    #                 echo "Adding CUDA to CUDA_PATH, CUDA_PATH_X_Y and PATH"
    #                 echo "CUDA_PATH=$env:CUDA_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
    #                 echo "$env:CUDA_PATH_VX_Y=$env:CUDA_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
    #                 echo "$env:CUDA_PATH/bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
    #               } else {
    #                 exit 1
    #               }

    #         - name: Verify that NVCC is Installed on GHA Windows Machine
    #           if: runner.os == 'Windows' && matrix.config.cuda
    #           shell: powershell
    #           run: |
    #               nvcc -V
    #               ls $env:CUDA_PATH
    #               ls $env:CUDA_PATH\bin
    #               ls $env:CUDA_PATH\include

    #         - name: Register OS Compiler Matchers
    #           shell: bash -e {0}
    #           run: |
    #               # OS-independent matchers
    #               echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/cppcheck_matcher.json"
    #               echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/cmake_matcher.json"

    #               # OS-specific matchers
    #               if [ "$RUNNER_OS" == "Linux" ]; then
    #                   echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/gcc_matcher.json"
    #               elif [ "$RUNNER_OS" == "Windows" ]; then
    #                   echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/msvc_matcher.json"
    #               elif [ "$RUNNER_OS" == "macOS" ]; then
    #                   echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"
    #               fi

    #         ############################# Windows Configuration Steps END #############################

    #         ############################# Unix Configuration Steps START #############################

    #         - name: Install Linux/MacOS Client Protocol Dependencies on Linux/MacOS GHA Machines
    #           if: runner.os == 'Linux' || runner.os == 'macOS'
    #           shell: bash -e {0}
    #           working-directory: protocol
    #           run: |
    #               if [ "$RUNNER_OS" == "Linux" ]; then
    #                   # update apt before installing packages to avoid package not found errors
    #                   sudo apt-get update

    #                   # install Linux protocol dependencies
    #                   ./setup-linux-build-environment.sh

    #                   # install clang-tidy, coreutils for realpath, and perl
    #                   # we must hardcode this version, else we will install the overaggressive recent version
    #                   sudo apt-get install -y clang-tidy-6.0 coreutils perl cppcheck

    #                   # we also need to symlink it so it can be called as clang-tidy
    #                   sudo ln -s "/usr/bin/clang-tidy-6.0" "/usr/bin/clang-tidy"
    #               else
    #                   # llvm for clang-tidy, coreutils for realpath
    #                   # llvm@7 is used so that clang-tidy reads "-p" argument correctly on MacOS
    #                   brew install llvm@7 coreutils perl
    #                   ln -s "/usr/local/opt/llvm@7/bin/clang-format" "/usr/local/bin/clang-format"
    #                   ln -s "/usr/local/opt/llvm@7/bin/clang-tidy" "/usr/local/bin/clang-tidy"
    #               fi

    #         ############################# Unix Configuration Steps END #############################

    #         - name: Build Protocol Client and Server on Windows
    #           if: runner.os == 'Windows'
    #           shell: cmd # Acts as Visual Studio Developer Command Prompt due to ilammy/msvc-dev-cmd@v1
    #           working-directory: protocol
    #           run: |
    #               mkdir build
    #               cd build
    #               cmake .. -DCMAKE_BUILD_TYPE=Debug -DCI=TRUE -G "Ninja" || EXIT /B 1
    #               ninja FractalClient || EXIT /B 1
    #               ninja FractalServer || EXIT /B 1

    #         - name: Build Protocol Client on Linux/MacOS
    #           if: runner.os == 'Linux' || runner.os == 'macOS'
    #           env:
    #               FRACTAL_OSX_SYSROOT: "/Applications/Xcode_12.2.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk" # Necessary for building on macOS
    #           working-directory: protocol
    #           run: |
    #               mkdir build
    #               cd build
    #               cmake .. -DCMAKE_BUILD_TYPE=Debug -DCI=TRUE
    #               make FractalClient -j

    #         - name: Build Protocol Server on Linux
    #           if: runner.os == 'Linux'
    #           working-directory: protocol
    #           run: |
    #               cd build
    #               make FractalServer -j

    #         # Verify clang-format on Linux
    #         - name: Verify Builds with clang-format
    #           if: runner.os == 'Linux'
    #           working-directory: protocol
    #           run: |
    #               # Clang-matcher for clang-format, added after the main build sequence so that clang doesn't match gcc errors
    #               echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"

    #               cd build
    #               make clang-format -j

    #               # Show diff in GitHub Actions logs
    #               git diff HEAD --

    #               # This will return an error if there is a non-empty diff
    #               git diff-index --quiet HEAD --

    #         # Verify clang-tidy on all OS's
    #         - name: Verify Builds with clang-tidy on Linux/MacOS
    #           if: runner.os == 'Linux' || runner.os == 'macOS'
    #           working-directory: protocol
    #           run: |
    #               # Clang-matcher for clang-tidy, added after the main build sequence so that clang doesn't match gcc/msvc errors
    #               echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"

    #               cd build
    #               make clang-tidy -j

    #         - name: Verify builds with clang-tidy on Windows
    #           if: runner.os == 'Windows'
    #           shell: cmd # Acts as Visual Studio Developer Command Prompt due to ilammy/msvc-dev-cmd@v1
    #           working-directory: protocol
    #           run: |
    #               # Clang-matcher for clang-tidy, added after the main build sequence so that clang doesn't match gcc/msvc errors
    #               echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"

    #               cd build
    #               ninja clang-tidy || EXIT /B 1

    #         # This tests building the protocol in a container, the same way we do it in production
    #         - name: Build Protocol Server in Docker Container
    #           if: runner.os == 'Linux'
    #           working-directory: protocol
    #           run: ./build_protocol.sh release

    #         # This ensures that all the build files from build_protocol.sh have actually been generated
    #         - name: Ensure that all protocol build files are present
    #           if: runner.os == 'Linux'
    #           working-directory: container-images
    #           run: ./helper-scripts/copy_protocol_build.sh
    main-webserver-load-testing:
        name: Main Webserver Load Testing
        runs-on: ubuntu-20.04

        env:
            webserver_url: "https://dev-server.fractal.co"
            heroku_app_name: "fractal-dev-server"
            num_users: "1"

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2
              # with:
              #   # checkout staging branch
              #   ref: "staging"

            - name: Configure AWS CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_EC2_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_EC2_SECRET_ACCESS_KEY }}
                  aws-region: us-east-1

            - name: Authenticate Heroku
              run: |
                  cat > ~/.netrc << EOF
                  machine api.heroku.com
                    login ${{ secrets.HEROKU_DEVELOPER_LOGIN_EMAIL }}
                    password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
                  machine git.heroku.com
                    login ${{ secrets.HEROKU_DEVELOPER_LOGIN_EMAIL }}
                    password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
                  EOF

            - name: Set up Python 3.8
              uses: actions/setup-python@v2
              with:
                  python-version: 3.8

            - name: Install webserver scripting dependencies
              working-directory: main-webserver
              run: pip install -r scripts/requirements.txt

            - name: Setup and run load test
              working-directory: main-webserver
              shell: python3 {0}
              run: |
                  # this allows us to import from `scripts`
                  import sys
                  sys.path.append(".")
                  import subprocess
                  import time

                  from scripts.misc_scripts import login  
                  from scripts.load_testing.load_test_management import (
                      upgrade_webserver,
                      downgrade_webserver,
                  )
                  from scripts.load_testing.load_test_driver import run_local_load_test

                  WEBSERVER_URL = "${{ env.webserver_url }}"
                  HEROKU_APP_NAME = "${{ env.heroku_app_name }}"
                  NUM_USERS = int("${{ env.num_users }}")
                  USERNAME = "${{ secrets.HEROKU_ALL_WEBSERVERS_ADMIN_USERNAME }}"
                  PASSWORD = "${{ secrets.HEROKU_ALL_WEBSERVERS_ADMIN_PASSWORD }}"

                  # use heroku to get the database url for the current app
                  ret = subprocess.run(f"heroku config:get DATABASE_URL --app {HEROKU_APP_NAME}", capture_output=True, shell=True)
                  assert ret.returncode == 0, f"Heroku DATABASE_URL retrieval failed. Stdout: {ret.stdout}, Stderr: {ret.stderr}"
                  DB_URI = ret.stdout.decode("utf-8").strip()

                  # Log in as Admin to get Bearer Token
                  TOKEN = login(WEBSERVER_URL, USERNAME, PASSWORD)["access_token"]

                  # --- Setup load test --- #
                  # Upgrade the heroku app for prod-like use
                  upgrade_webserver(HEROKU_APP_NAME)

                  try:
                    # Until we fix high initial task latency, we need to do one lambda invocation
                    # to sidestep the first task's high latency issue
                    run_local_load_test(WEBSERVER_URL, TOKEN, NUM_USERS)

                  except Exception as e:
                    # we just need the finally block to run before exiting badly
                    raise e
                    
                  finally:
                    # --- Cleanup load test --- #
                    # run this always; restores webserver to its original state
                    downgrade_webserver(HEROKU_APP_NAME)

            - name: Notify Slack on success
              run: |
                  WEBSERVER_URL=${{ env.webserver_url }}

                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts-test\", \"username\": \"Fractal Bot\", \"text\": \"Successfully load tested webserver at $WEBSERVER_URL in github workflow \`${{ github.run_id }}\`.\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

            - name: Notify Slack on failure
              if: ${{ failure() }}
              run: |
                  WEBSERVER_URL=${{ env.webserver_url }}

                  # Notify slack of failure.
                  curl -X POST \
                    --data-urlencode \
                    "payload={\"channel\": \"#alerts-test\", \"username\": \"Fractal Bot\", \"text\": \"Failed load testing webserver at $WEBSERVER_URL in github workflow \`${{ github.run_id }}\`.\", \"icon_emoji\": \":fractal:\"}" \
                    ${{ secrets.SLACK_HOOKS_ENDPOINT }}
