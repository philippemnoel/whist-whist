# workflows/protocol-check-pr.yml
#
# Protocol: Check PR
# Checks a protocol PR for building, linting, and clang standards success

name: "Protocol: Check PR"

on:
  push:
    # Trigger runs on our default branch, `dev`, to upload code coverage reports to Codecov
    branches:
      - dev
    paths:
      - "protocol/**"
      - "!protocol/**/README.md"
      - ".github/workflows/protocol-check-pr.yml"
      - "mandelboxes/helper_scripts/copy_protocol_build.sh"
  pull_request:
    paths:
      - "protocol/**"
      - "!protocol/**/README.md"
      - ".github/workflows/protocol-check-pr.yml"
      - "mandelboxes/helper_scripts/copy_protocol_build.sh"
  workflow_dispatch:

jobs:
  # Check Protocol PR on Intel X86_64 systems (via GHA runners)
  protocol-check-pr-building-linting-x64:
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}

    strategy:
      matrix:
        config:
          - name: "Build and Check Protocol on Windows (cl)"
            os: windows-2019 # llvm, cmake, clang-tidy are pre-installed on windows-2019+ GHA machines
            cuda: false # Set to true to CUDA-optimize the windows server executable. Note that CUDA takes 5-7min to install.
          - name: "Build and Check Protocol on Linux Ubuntu (gcc)"
            os: ubuntu-20.04 # cmake is pre-installed on ubuntu-20.04+ machines
          - name: "Build and Check Protocol on macOS X64 (clang)"
            os: macos-10.15 # cmake is pre-installed on macos-10.15+ machines

    env:
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

    steps:
      ################################## CONFIG STEPS START ##############################

      - name: Checkout Git Repository
        uses: actions/checkout@v2

      # Necessary for downloading protocol libs and base Dockerfile NVIDIA GRID drivers from AWS S3
      - name: Configure AWS S3 CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      ###################################################################################
      ################################ WINDOWS STEPS START ##############################

      - name: Install Chocolatey dependencies on Windows GHA Machine
        if: runner.os == 'Windows'
        uses: crazy-max/ghaction-chocolatey@v1
        with:
          args: install cppcheck ninja

      - name: Set up Visual Studio Developer Command Prompt (for nmake) on Windows GHA Machine
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      - name: Install CUDA on Windows GHA Machine
        if: runner.os == 'Windows' && matrix.config.cuda
        working-directory: .github\workflows\helpers\protocol
        env:
          visual_studio: "Visual Studio 16 2019" # Imported from env in the .ps1 script
          cuda: "11.0.167" # Imported from env in the .ps1 script, we use CUDA 11.0
        shell: powershell
        run: |
          # Install CUDA and set paths
          .\install_cuda_windows.ps1
          if ($?) {
            # Set paths for subsequent steps, using $env:CUDA_PATH
            echo "Adding CUDA to CUDA_PATH, CUDA_PATH_X_Y and PATH"
            echo "CUDA_PATH=$env:CUDA_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            echo "$env:CUDA_PATH_VX_Y=$env:CUDA_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
            echo "$env:CUDA_PATH/bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          } else {
            exit 1
          }

      - name: Verify that NVCC is Installed on GHA Windows Machine
        if: runner.os == 'Windows' && matrix.config.cuda
        shell: powershell
        run: |
          nvcc -V
          ls $env:CUDA_PATH
          ls $env:CUDA_PATH\bin
          ls $env:CUDA_PATH\include

      - name: Register OS Compiler Matchers
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          # OS-independent matchers
          echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/cppcheck_matcher.json"
          echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/cmake_matcher.json"

          # OS-specific matchers
          if [ "$RUNNER_OS" == "Linux" ]; then
              echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/gcc_matcher.json"
          elif [ "$RUNNER_OS" == "Windows" ]; then
              echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/msvc_matcher.json"
          elif [ "$RUNNER_OS" == "macOS" ]; then
              echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"
          fi

      - name: Build and Test Protocol Client and Server on Windows
        if: runner.os == 'Windows'
        shell: cmd # Acts as Visual Studio Developer Command Prompt due to ilammy/msvc-dev-cmd@v1
        working-directory: protocol
        run: |
          mkdir build
          cd build
          cmake .. -DCMAKE_BUILD_TYPE=Debug -DCHECK_CI=TRUE -G "Ninja" || EXIT /B 1
          ninja FractalClient FractalProtocolTest || EXIT /B 1
          ninja FractalServer FractalProtocolTest || EXIT /B 1

      - name: Verify builds with clang-tidy on Windows
        if: runner.os == 'Windows'
        shell: cmd # Acts as Visual Studio Developer Command Prompt due to ilammy/msvc-dev-cmd@v1
        working-directory: protocol
        run: |
          # Clang-matcher for clang-tidy, added after the main build sequence so that clang doesn't match gcc/msvc errors
          echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"

          # Run clang-tidy
          cd build
          ninja clang-tidy || EXIT /B 1

      ###################################################################################
      ################################# MACOS STEPS START ###############################

      - name: Install macOS Client Protocol Dependencies on macOS GHA Machines
        if: runner.os == 'macOS'
        working-directory: protocol
        run: |
          # llvm for clang-tidy, coreutils for realpath, lcov for codecov
          brew install llvm coreutils perl doxygen lcov
          ln -s "/usr/local/opt/llvm/bin/clang-format" "/usr/local/bin/clang-format"
          ln -s "/usr/local/opt/llvm/bin/clang-tidy" "/usr/local/bin/clang-tidy"

      - name: Build and Test Protocol Client on macOS
        if: runner.os == 'macOS'
        working-directory: protocol
        env:
          WHIST_OSXSYSROOT: "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
        run: |
          # Build the protocol and its test suite
          mkdir build
          cd build
          cmake .. -DCMAKE_BUILD_TYPE=Debug -DCHECK_CI=TRUE
          make FractalClient FractalProtocolTest -j

      - name: Build and Test Protocol Client on Linux Ubuntu
        if: runner.os == 'Linux'
        working-directory: protocol
        run: ./build_protocol_targets.sh --cmakebuildtype=Debug --cmakesetCI FractalClient FractalProtocolTest

      - name: Verify Builds with clang-tidy on macOS
        if: runner.os == 'macOS'
        working-directory: protocol
        run: |
          # Clang-matcher for clang-tidy, added after the main build sequence so that clang doesn't match gcc/msvc errors
          echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"

          # Run clang-tidy
          cd build
          make clang-tidy -j

      ###################################################################################
      ################################# LINUX STEPS START ###############################

      - name: Build and Test Protocol Client on Linux Ubuntu
        if: runner.os == 'Linux'
        working-directory: protocol
        run: ./build_protocol_targets.sh --cmakebuildtype=Debug --cmakesetCI FractalClient FractalProtocolTest

      - name: Build Protocol Server on Linux Ubuntu
        if: runner.os == 'Linux'
        working-directory: protocol
        run: ./build_protocol_targets.sh --cmakebuildtype=Debug --cmakesetCI FractalServer FractalProtocolTest

      # Verify clang-format on Linux
      - name: Verify Builds with clang-format
        if: runner.os == 'Linux'
        working-directory: protocol
        run: |
          # Clang-matcher for clang-format, added after the main build sequence so that clang doesn't match gcc errors
          echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"

          # Print clang-format version for local comparison
          clang-format --version

          # Run clang-format
          ./build_protocol_targets.sh clang-format

          # Show diff in GitHub Actions logs
          git diff HEAD .

          # This will return an error if there is a non-empty diff
          git diff-index --quiet HEAD .

      - name: Verify Builds with clang-tidy on Linux Ubuntu
        if: runner.os == 'Linux'
        working-directory: protocol
        run: |
          # Clang-matcher for clang-tidy, added after the main build sequence so that clang doesn't match gcc/msvc errors
          echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"

          # Run clang-tidy
          ./build_protocol_targets.sh clang-tidy

      # This tests building the protocol in a container, the same way we do it in production
      - name: Build Protocol Server in Docker Container
        if: runner.os == 'Linux'
        working-directory: protocol
        run: ./build_protocol_targets.sh --cmakebuildtype=Release FractalServer FractalProtocolTest

      # This ensures that all the build files from build_protocol_targets.sh have actually been generated
      - name: Ensure that all protocol build files are present
        if: runner.os == 'Linux'
        working-directory: mandelboxes
        run: ./helper_scripts/copy_protocol_build.sh

      - name: Lint CMake Files
        if: runner.os == 'Linux'
        working-directory: protocol
        run: |
          pip3 install cmakelint
          sudo apt-get install fd-find
          # Ubuntu-specific PATH fix for `fd`
          ln -s $(which fdfind) ~/.local/bin/fd
          ./lint-cmake.sh

  #######################################################################################
  #######################################################################################

  # Check Protocol PR on ARM64 systems (via self-hosted MacStadium M1 runner)
  protocol-check-pr-building-linting-arm64:
    name: Build and Test Protocol on macOS ARM64 (clang)
    runs-on: [self-hosted, macOS, ARM64]
    defaults:
      run:
        shell: "/usr/bin/arch -arch arm64e /bin/bash {0}"

    steps:
      ################################## CONFIG STEPS START ##############################

      - name: Checkout Git Repository
        uses: actions/checkout@v2

      # Necessary for downloading protocol libs and base Dockerfile NVIDIA GRID drivers from AWS S3
      - name: Configure AWS S3 CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      ###################################################################################
      ################################# MACOS STEPS START ###############################

      # These commands must be run with sudo, which requires entering the password. They need
      # to be run via VNC directly in the terminal, so that the password can be provided. They
      # are left here, commented out, for reference
      # - name: Install macOS Client Protocol Dependencies
      #   if: runner.os == 'macOS'
      #   working-directory: protocol
      #   run: |
      #     # llvm for clang-tidy, coreutils for realpath, lcov for codecov
      #     brew install llvm coreutils perl doxygen lcov
      #     sudo ln -s "/opt/homebrew/opt/llvm/bin/clang-format" "/usr/local/bin/clang-format"
      #     sudo ln -s "/opt/homebrew/opt/llvm/bin/clang-tidy" "/usr/local/bin/clang-tidy"

      - name: Build and Test Protocol Client
        working-directory: protocol
        env:
          WHIST_OSXSYSROOT: "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
        run: |
          mkdir build
          cd build
          cmake .. -DCMAKE_BUILD_TYPE=Debug -DCI=TRUE
          make FractalClient FractalProtocolTest -j

          # Generate code coverage report from .gcno/.gcda files generated by `clang --coverage`
          lcov --capture --directory . --output-file coverage.info
          lcov --list coverage.info # debug info

          # Download the Codecov uploader
          curl -Os https://uploader.codecov.io/latest/macos/codecov && chmod +x codecov

          # Upload coverage report to Codecov
          ./codecov -t ${CODECOV_TOKEN} -c -F protocol

      - name: Verify Builds with clang-tidy on macOS
        if: runner.os == 'macOS'
        working-directory: protocol
        run: |
          # Clang-matcher for clang-tidy, added after the main build sequence so that clang doesn't match gcc/msvc errors
          echo " ::add-matcher::${{ github.workspace }}/.github/workflows/helpers/protocol/clang_matcher.json"

          # Run clang-tidy
          cd build
          make clang-tidy -j

  #######################################################################################
  #######################################################################################

  # Check Protocol PR streaming performance between two AWS EC2 instances
  # The system is defined as follows:
  # The client is a weak GHA macOS machine. The server is our regular g4dn.2xlarge
  # AWS instance. Since GHA is Azure, this ensures data will at least be streamed over the
  # Internet, not just within an AWS datacenter.
  # Eventually, we could make this spin up different instances in different AWS regions, to
  # increase streaming distance and network conditions. We could also simulate specific
  # network conditions.
  protocol-check-pr-streaming-performance:
    name: Test Protocol Streaming Performance
    runs-on: macos-10.15 # We only support macOS clients currently, so we use a macOS runner
    steps:
      ################################## CONFIG STEPS START ##############################

      - name: Checkout Git Repository
        uses: actions/checkout@v2

      # Necessary for downloading protocol libs and base Dockerfile NVIDIA GRID drivers from AWS S3
      - name: Configure AWS S3 CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set up Python-based AWS helper functions folder
        working-directory: .github/workflows/helpers
        run: ./aws/setup_aws.sh

      - name: Install Dependencies
        run: pip3 install boto3 paramiko # paramiko is our SSH client

      ######################################################################################
      ################################## SERVER SETUP START ################################

      # 1- Create a new EC2 instance
      - name: Create EC2 Test Server Instance
        shell: python3 {0}
        run: |
          from aws.testing_helpers import create_ec2_instance, wait_for_instance_to_start_or_stop, get_instance_ip, wait_for_ssh
          import paramiko

          # Retrieve SSH key from AWS Configure
          ssh_key = paramiko.Ed25519Key.from_private_key_file("/Users/runner/.ssh/id_ed25519") # Default path on macOS
          AMI = "ami-0885b1f6bd170450c" # The base AWS-provided AMI we build our AMI from: AWS Ubuntu Server 20.04 LTS
          instance_type = "g4dn.2xlarge" # The type of instance we want to create

          # Create a new EC2 instance
          server_instance_id = create_ec2_instance(instance_type=instance_type, instance_AMI=AMI, key_name=ssh_key)
          print(f"Created server instance {server_instance_id}")

          # Give a little time for the instance to be recognized in AWS
          time.sleep(5)

          # Wait for the instance to be running
          wait_for_instance_to_start_or_stop(server_instance_id, stopping=False)
          print(f"Server instance {server_instance_id} is running")

          # Get the IP address of the instance
          server_instance_ip = get_instance_ip(server_instance_id)
          print(f"Server instance {server_instance_id} has IP address {server_instance_ip}")

          # Initiate SSH connection with the instance
          wait_for_ssh(server_instance_ip, ssh_key)
          print(f"SSH connection to server instance {server_instance_id} established")

          # Sleep so that the SSH connections resets
          time.sleep(1)

          # Server initialized, echo-ing IP address so that we can continue in a new 
          # YAML step, for better readability
          print(f"::set-output name=server_instance_ip::{server_instance_ip}")

      # 2- Configure it for local development
      - name: Configure Test Server Instance for Running Whist
        shell: python3 {0}
        run: |
          from aws.testing_helpers import run_ssh_command


          1- Authenticate to Git


          2- Fetch the monorepo


          3- Run the host-setup


          4- Build the host-service (we won't rebuild the mandelbox, since we're only testing protocol here)



          5- Run the protocol server, and retrieve the value

          t3 = threading.Thread(target=run_ssh_command, args=(instance_ips[0], cmd, key, False))

          # potential code for parsing the client command
          temp = result.split(b'\n')
          client_command = temp[6][temp[6].index(b'.')+2:].decode("utf-8")
          print(client_command)

      # 3- Retrieve this monorepo
      # 2- Configure it for local development
      # 3- Reboot it
      # 4- Build and run

      # 4- Retrieve the monorepo

      ######################################################################################
      ################################## CLIENT SETUP START ################################

      - name: Build and Protocol Client on macOS
        working-directory: protocol
        env:
          WHIST_OSXSYSROOT: "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
        run: |
          # Build the protocol
          mkdir build && cd build
          cmake .. -DCMAKE_BUILD_TYPE=Debug -DCHECK_CI=TRUE # Could make a new build type for performance testing, and retrive metris from protocol directly by reading log file!
          make -j FractalClient

      - name: Test Performance for 4 Minutes
        working-directory: protocol/build
        run: |
          # Run the protocol client timing out after 240 seconds (4 minutes)
          timeout 240 ./fclient [need to swap for args here] -l

          # TODO
          # Here we will want to read the .log file and retrieve all of the info we want. We could display it as 
          # a comment on the PR using Neil's Slack bot automator (see webserver DB migration, which does this) or
          # eventually, run this nightly and put it up on Logz.io

      - name: Wrap up testing, shut down server instance
        run: |
          # Terminating the instances and waiting for them to shutdown
          print(f"Testing complete, terminating instances with ids: {instance_ids}")
          client.terminate_instances(InstanceIds=instance_ids)

          wait_for_instances(instance_ids, stopping=True)
          print("Instances successfully terminated, goodbye")
