# workflows/protocol-build-dependencies.yml
#
# Build & Publish Whist Protocol dependencies
# Build and publish Whist version-compatible builds of the Whist protocol
# dependencies to AWS S3. This workflow only builds non-forked dependencies,
# forked dependencies, i.e. SDL, are forked as whisthq/<dependency> (i.e. whisthq/SDL) and
# published directly from the forked repository

name: "Protocol: Build & Publish Dependencies"

# We deploy new dependencies on modifications to this file (i.e. building a new version) or
# manual dispatch on our default repository branch, which is `dev`
on:
  pull_request:
    branches:
      - dev
    paths:
      - ".github/workflows/protocol-build-dependencies.yml"
  push:
    branches:
      - dev
    paths:
      - ".github/workflows/protocol-build-dependencies.yml"
  workflow_dispatch:

# This guarantees that if you push many commits to the same PR, only the latest
# commit will get run (others get cancelled)
concurrency:
  group: protocol-build-dependencies-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

jobs:
  # Dependency #1 -- OpenSSL
  build-and-publish-openssl:
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}

    strategy:
      matrix:
        config:
          - name: "OpenSSL (Windows)"
            os: windows-2019
            arch: x86_64
          - name: "OpenSSL (macOS x64)"
            os: macos-10.15
            arch: x86_64
          - name: "OpenSSL (macOS arm64)"
            os: macos-11
            arch: arm64
          - name: "OpenSSL (Ubuntu Linux)"
            os: ubuntu-20.04
            arch: x86_64

    env:
      windows-tar-name: whist-windows-libcrypto-static-lib.tar.gz
      macos-x64-tar-name: whist-macos-x64-libcrypto-static-lib.tar.gz
      macos-arm64-tar-name: whist-macos-arm64-libcrypto-static-lib.tar.gz
      linux-tar-name: whist-linux-libcrypto-static-lib.tar.gz
      headers-tar-name: whist-libcrypto-headers.tar.gz
      s3-bucket-uri: s3://whist-protocol-dependencies
      s3-bucket-region: us-east-1

    steps:
      ################################# CONFIG STEPS START ###############################

      - name: Checkout OpenSSL Git Repository
        uses: actions/checkout@v3
        with:
          repository: openssl/openssl
          ref: OpenSSL_1_1_1m # GitHub Tag of latest stable OpenSSL release

      - name: Configure AWS S3 CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.s3-bucket-region }}

      ###################################################################################
      ################################ WINDOWS STEPS START ##############################

      - name: On Windows, Set up Visual Studio Developer Command Prompt (for nmake)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      - name: On Windows, Set up NASM
        if: runner.os == 'Windows'
        uses: ilammy/setup-nasm@v1

      - name: Build Whist OpenSSL on Windows
        if: runner.os == 'Windows'
        shell: cmd # Acts as Visual Studio Developer Command Prompt due to ilammy/msvc-dev-cmd@v1
        run: |
          REM configure and build OpenSSL for Windows on the GitHub Actions Windows OS Version, with -O2/-O3 flag
          perl Configure VC-WIN64A --release
          nmake

      ###################################################################################
      ################################# MACOS STEPS START ###############################

      - name: Build Whist OpenSSL on macOS
        if: runner.os == 'macOS'
        run: |
          if [[ "${{ matrix.config.arch }}" == "x86_64" ]]; then
            # configure and build OpenSSL for native compilation on x64 systems
            export CFLAGS="-mmacosx-version-min=10.13 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
            export CXXFLAGS="-mmacosx-version-min=10.13 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"

            # configure and build OpenSSL with -O2/-O3 flag
            ./Configure darwin64-x86_64-cc --release
            make -j
          elif [[ "${{ matrix.config.arch }}" == "arm64" ]]; then
            # configure and build OpenSSL for cross-compilation to arm64 from x64 systems
            export CFLAGS="-mmacosx-version-min=11.0 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
            export CXXFLAGS="-mmacosx-version-min=11.0 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"

            # configure and build OpenSSL with -O2/-O3 flag
            ./Configure darwin64-arm64-cc --release
            make -j
          else
            echo "Unsupported compilation attempt on macOS"
            exit
          fi

      ###################################################################################
      ################################# LINUX STEPS START ###############################

      - name: Build Whist OpenSSL on Ubuntu Linux
        if: runner.os == 'Linux'
        env:
          DEBIAN_FRONTEND: "noninteractive"
        run: |
          # configure and build OpenSSL with -O2/-O3 flag
          ./config --release
          make -j

      ###################################################################################
      ################################# PUBLISH STEPS START #############################

      # Only publish to AWS S3 on Push events (code merged into `dev`), PRs only build to test
      - name: Tar libcrypto and Upload to AWS S3 (Only on Push/Workflow_dispatch Events)
        if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          if [ "$RUNNER_OS" == "Linux" ]; then
            tar -zcvf ${{ env.linux-tar-name }} libcrypto.a
            aws s3 cp ${{ env.linux-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.linux-tar-name }}
          elif [ "$RUNNER_OS" == "Windows" ]; then
            tar -zcvf ${{ env.windows-tar-name }} libcrypto-1_1-x64.dll libcrypto.lib
            aws s3 cp ${{ env.windows-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.windows-tar-name }}
          else
            if [[ "${{ matrix.config.arch }}" == "x86_64" ]]; then
              tar -zcvf ${{ env.macos-x64-tar-name }} libcrypto.a
              aws s3 cp ${{ env.macos-x64-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.macos-x64-tar-name }}
            elif [[ "${{ matrix.config.arch }}" == "arm64" ]]; then
              tar -zcvf ${{ env.macos-arm64-tar-name }} libcrypto.a
              aws s3 cp ${{ env.macos-arm64-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.macos-arm64-tar-name }}
            else
              echo "Tried to tar and upload to S3 for an unsupported OS"
              exit
            fi
          fi

      # Only run once, as headers are identical on every OS
      - name: Tar OpenSSL headers and Upload to AWS S3 (Only on Push/Workflow_dispatch Events)
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && runner.os == 'Linux'}}
        run: |
          # remove all .h.in unnecessary files
          find . -name "*.h.in" -type f -delete

          # move headers in include/openssl/ to include/, and delete /openssl folder
          mv include/openssl/* include/
          rmdir include/openssl

          # tar and upload the OpenSSL headers only
          tar -zcvf ${{ env.headers-tar-name }} include
          aws s3 cp ${{ env.headers-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.headers-tar-name }}

      ###################################################################################

      - name: Checkout whisthq/whist Git Repository
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && failure() }}
        uses: actions/checkout@v3

      - name: Setup Python-based notifications
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && failure() }}
        working-directory: .github/workflows/helpers
        shell: bash --noprofile --norc -eo pipefail {0}
        run: ./notifications/setup_notifications.sh

      - name: Notify Slack on Workflow Error (Only on Push/Workflow_dispatch Events)
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && failure() }}
        shell: python3 {0}
        run: |
          from notifications.slack_bot import slack_post
          SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          BODY = f"@releases :rotating_light: Failed to deploy OpenSSL `libcrypto` X86_64 Static Library to AWS S3, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

  #######################################################################################
  #######################################################################################

  # Dependency #2 -- Sentry
  build-and-publish-sentry:
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}

    strategy:
      matrix:
        config:
          - name: "Sentry (Windows)"
            os: windows-2019
            arch: x86_64
          - name: "Sentry (macOS x64)"
            os: macos-10.15
            arch: x86_64
          - name: "Sentry (macOS arm64)"
            os: macos-11
            arch: arm64
          - name: "Sentry (Ubuntu Linux)"
            os: ubuntu-20.04
            arch: x86_64

    env:
      windows-tar-name: whist-windows-sentry-shared-lib.tar.gz
      macos-x64-tar-name: whist-macos-x64-sentry-shared-lib.tar.gz
      macos-arm64-tar-name: whist-macos-arm64-sentry-shared-lib.tar.gz
      linux-tar-name: whist-linux-sentry-shared-lib.tar.gz
      headers-tar-name: whist-sentry-headers.tar.gz
      s3-bucket-uri: s3://whist-protocol-dependencies
      s3-bucket-region: us-east-1

    steps:
      ################################# CONFIG STEPS START ###############################

      - name: Checkout Sentry Native Git Repository
        uses: actions/checkout@v3
        with:
          repository: getsentry/sentry-native
          ref: "0.4.15" # GitHub Tag of the Sentry release we use
          submodules: recursive # Sentry uses (nested) submodules for external dependencies

      - name: Configure AWS S3 CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.s3-bucket-region }}

      ###################################################################################
      ################################ WINDOWS STEPS START ##############################

      - name: Install cmake via Chocolatey on Windows GHA Machine
        if: runner.os == 'Windows'
        uses: crazy-max/ghaction-chocolatey@v1
        with:
          args: install cmake --pre --no-progress --installargs 'ADD_CMAKE_TO_PATH=System'

      - name: On Windows, Set up Visual Studio Developer Command Prompt (for nmake)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      - name: On Windows, Set up NASM
        if: runner.os == 'Windows'
        uses: ilammy/setup-nasm@v1

      - name: Build Sentry Native on Windows
        if: runner.os == 'Windows'
        shell: cmd # Acts as Visual Studio Developer Command Prompt due to ilammy/msvc-dev-cmd@v1
        run: |
          REM configure and build Sentry Native for Windows on the GitHub Actions Windows OS Version
          cmake -S . ^
                -B build ^
                -D CMAKE_BUILD_TYPE=Release ^
                -D SENTRY_BUILD_SHARED_LIBS=ON ^
                -D SENTRY_BUILD_RUNTIMESTATIC=ON ^
                -D SENTRY_BUILD_TESTS=OFF ^
                -D SENTRY_BACKEND=crashpad ^
                -G Ninja
          ninja -C build
          move build\crashpad_build\handler\crashpad_handler.exe .
          move build\sentry.dll .
          move build\sentry.lib .

      ###################################################################################
      ################################# MACOS STEPS START ###############################

      - name: Build Sentry Native on macOS
        if: runner.os == 'macOS'
        env:
          CMAKE_OSX_SYSROOT: "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"
        run: |
          if [[ "${{ matrix.config.arch }}" == "x86_64" ]]; then
            # configure Cmake and build Sentry Native for native compilation on x64 systems
            cmake -S . \
                  -B build \
                  -D CMAKE_BUILD_TYPE=Release \
                  -D SENTRY_BUILD_SHARED_LIBS=ON \
                  -D SENTRY_BUILD_RUNTIMESTATIC=ON \
                  -D SENTRY_BUILD_TESTS=OFF \
                  -D SENTRY_BACKEND=crashpad \
                  -D CMAKE_OSX_DEPLOYMENT_TARGET="10.13" \
                  -D CMAKE_OSX_SYSROOT="${{ env.CMAKE_OSX_SYSROOT }}"

            cd build && make -j

            # move files to location for publish steps to tar
            mv crashpad_build/handler/crashpad_handler ..
            mv libsentry.dylib ..
          elif [[ "${{ matrix.config.arch }}" == "arm64" ]]; then
            # configure Cmake and build Sentry Native for cross-compilation to arm64 from x64 systems
            cmake -S . \
                  -B build \
                  -D CMAKE_BUILD_TYPE=Release \
                  -D SENTRY_BUILD_SHARED_LIBS=ON \
                  -D SENTRY_BUILD_RUNTIMESTATIC=ON \
                  -D SENTRY_BUILD_TESTS=OFF \
                  -D SENTRY_BACKEND=crashpad \
                  -D CMAKE_OSX_DEPLOYMENT_TARGET="11.0" \
                  -D CMAKE_OSX_ARCHITECTURES="arm64" \
                  -D CMAKE_OSX_SYSROOT="${{ env.CMAKE_OSX_SYSROOT }}"

            cd build && make -j

            # move files to location for publish steps to tar
            mv crashpad_build/handler/crashpad_handler ..
            mv libsentry.dylib ..
          else
            echo "Unsupported compilation attempt on macOS"
            exit
          fi

      ###################################################################################
      ################################# LINUX STEPS START ###############################

      - name: Build Sentry Native on Ubuntu Linux
        if: runner.os == 'Linux'
        env:
          DEBIAN_FRONTEND: "noninteractive"
        run: |
          # install needed dependencies
          sudo apt-get update
          sudo apt-get install -y libcurl4-openssl-dev

          # configure and build Sentry Native
          cmake -S . \
                -B build \
                -D CMAKE_BUILD_TYPE=Release \
                -D SENTRY_BUILD_SHARED_LIBS=ON \
                -D SENTRY_BUILD_RUNTIMESTATIC=ON \
                -D SENTRY_BUILD_TESTS=OFF \
                -D SENTRY_BACKEND=crashpad
          cd build
          make -j

          # move files to location for publish steps to tar
          mv crashpad_build/handler/crashpad_handler ..
          mv libsentry.so ..

      ###################################################################################
      ################################# PUBLISH STEPS START #############################

      # Only publish to AWS S3 on Push events (code merged into `dev`), PRs only build to test
      - name: Tar Sentry and Upload to AWS S3 (Only on Push/Workflow_dispatch Events)
        if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          if [ "$RUNNER_OS" == "Linux" ]; then
          tar -zcvf ${{ env.linux-tar-name }} libsentry.so crashpad_handler
            aws s3 cp ${{ env.linux-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.linux-tar-name }}
          elif [ "$RUNNER_OS" == "Windows" ]; then
            tar -zcvf ${{ env.windows-tar-name }} sentry.dll sentry.lib crashpad_handler.exe
            aws s3 cp ${{ env.windows-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.windows-tar-name }}
          else
            if [[ "${{ matrix.config.arch }}" == "x86_64" ]]; then
              tar -zcvf ${{ env.macos-x64-tar-name }} libsentry.dylib crashpad_handler
              aws s3 cp ${{ env.macos-x64-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.macos-x64-tar-name }}
            elif [[ "${{ matrix.config.arch }}" == "arm64" ]]; then
              tar -zcvf ${{ env.macos-arm64-tar-name }} libsentry.dylib crashpad_handler
              aws s3 cp ${{ env.macos-arm64-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.macos-arm64-tar-name }}
            else
              echo "Tried to tar and upload to S3 for an unsupported OS"
              exit
            fi
          fi

      # Only run once, as headers are identical on every OS
      - name: Tar Sentry headers and Upload to AWS S3 (Only on Push/Workflow_dispatch Events)
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && runner.os == 'Linux'}}
        run: |
          # tar and upload the Sentry headers
          tar -zcvf ${{ env.headers-tar-name }} include
          aws s3 cp ${{ env.headers-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.headers-tar-name }}

      ###################################################################################

      - name: Checkout whisthq/whist Git Repository
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && failure() }}
        uses: actions/checkout@v3

      - name: Setup Python-based notifications
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && failure() }}
        working-directory: .github/workflows/helpers
        shell: bash --noprofile --norc -eo pipefail {0}
        run: ./notifications/setup_notifications.sh

      - name: Notify Slack on Workflow Error (Only on Push/Workflow_dispatch Events)
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && failure() }}
        shell: python3 {0}
        run: |
          from notifications.slack_bot import slack_post
          SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          BODY = f"@releases :rotating_light: Failed to deploy Sentry X86_64 `sentry-native` Shared Library to AWS S3, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

  #######################################################################################
  #######################################################################################

  # Dependency #3 -- FFmpeg
  build-and-publish-ffmpeg:
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}

    strategy:
      matrix:
        config:
          - name: "FFmpeg (Windows)"
            os: windows-2019
          - name: "FFmpeg (macOS x64)"
            os: macos-11
          - name: "FFmpeg (macOS arm64)"
            os: macos-11
          - name: "FFmpeg (Ubuntu Linux)"
            os: ubuntu-20.04

    env:
      windows-tar-name: whist-windows-ffmpeg-shared-lib.tar.gz
      windows-build-folder: Windows
      macos-x64-tar-name: whist-macos-x64-ffmpeg-shared-lib.tar.gz
      macos-arm64-tar-name: whist-macos-arm64-ffmpeg-shared-lib.tar.gz
      macos-build-folder: Darwin
      linux-tar-name: whist-linux-ffmpeg-shared-lib.tar.gz
      linux-build-folder: Linux
      headers-tar-name: whist-ffmpeg-headers.tar.gz
      headers-build-folder: include
      s3-bucket-region: us-east-1
      s3-bucket-uri: s3://fractal-protocol-shared-libs

    steps:
      ################################# CONFIG STEPS START ##############################

      - name: On macOS and Ubuntu Linux, Checkout this Git Repository Directly
        if: runner.os == 'macOS' || runner.os == 'Linux'
        uses: actions/checkout@v3

      # media-autobuild_suite needs to be directly in the C:\ drive, as it is very finicky with paths
      - name: On Windows, Git Clone whisthq/FFmpeg and whisthq/media-autobuild_suite (FFmpeg Windows Compilation Helper Tools) to C:\
        if: runner.os == 'Windows'
        shell: cmd
        run: |
          REM first, clone m-ab-s/media-autobuild_suite to C:\media-autobuild_suite
          REM note that this will use upstream FFmpeg, which is not the same as the Whist FFmpeg (this is only for Windows, we need to
          REM move macOS and Linux to also use upstream FFmpeg eventually, for consistency)
          git clone https://github.com/m-ab-s/media-autobuild_suite C:\media-autobuild_suite

          REM then, clone whisthq/whist to C:\media-autobuild_suite\build\whist (for helper files for m-ab-s)
          git clone "https://${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}@github.com/whisthq/whist.git" C:\media-autobuild_suite\build\whist

      - name: Configure AWS S3 CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.s3-bucket-region }}

      ###################################################################################
      ################################ WINDOWS STEPS START ##############################

      - name: On Windows, Install CUDA
        if: runner.os == 'Windows'
        working-directory: C:\media-autobuild_suite
        shell: powershell
        env:
          visual_studio: "Visual Studio 16 2019" # Imported from env in the .ps1 script
          cuda: "11.3.1" # Imported from env in the .ps1 script
        run: |
          & "C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\VC\Auxiliary\Build\vcvars64.bat"
          .\build\whist\.github\workflows\helpers\ffmpeg\install_cuda_windows.ps1
            if ($?) {
              # Set paths for subsequent steps, using $env:CUDA_PATH
              echo "Adding CUDA to CUDA_PATH, CUDA_PATH_X_Y and PATH"
              echo "CUDA_PATH=$env:CUDA_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
              echo "$env:CUDA_PATH_VX_Y=$env:CUDA_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
              echo "$env:CUDA_PATH/bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
            }

      - name: On Windows, Verify that NVCC is Installed
        if: runner.os == 'Windows'
        shell: powershell
        run: |
          nvcc -V
          ls $env:CUDA_PATH
          ls $env:CUDA_PATH\bin
          ls $env:CUDA_PATH\include

      - name: On Windows, Move Preconfigured media-autobuild_suite Config Files Over to C:\media-autobuild_suite/build
        if: runner.os == 'Windows'
        working-directory: C:\media-autobuild_suite
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          cp \
          build/whist/.github/workflows/helpers/ffmpeg/media-autobuild_suite.ini \
          build/whist/.github/workflows/helpers/ffmpeg/ffmpeg_options.txt \
          build/whist/.github/workflows/helpers/ffmpeg/mpv_options.txt \
          build/whist/.github/workflows/helpers/ffmpeg/bash.sh \
          build/whist/.github/workflows/helpers/ffmpeg/mingw.sh \
          build/whist/.github/workflows/helpers/ffmpeg/pacman.sh \
          build/

      - name: On Windows, build FFmpeg via media-autobuild_suite from C:\ drive
        if: runner.os == 'Windows'
        working-directory: C:\media-autobuild_suite
        shell: cmd
        run: .\media-autobuild_suite.bat

      ###################################################################################
      ################################# MACOS STEPS START ###############################

      - name: Install macOS Codesigning Certificates on macOS GHA Machine
        if: runner.os == 'macOS'
        uses: apple-actions/import-codesign-certs@v1
        with:
          p12-file-base64: ${{ secrets.MACOS_SIGNING_P12_CERTIFICATES_BASE64_ENCODED }}
          p12-password: ${{ secrets.MACOS_SIGNING_P12_CERTIFICATES_BASE64_ENCODED_PASSWORD }}

      # On Intel silicon, Homebrew installs libs to /usr/local/*
      - name: On macOS, Explicitly Set Proper Homebrew Folder Permissions for Linking FFmpeg Dependencies
        if: runner.os == 'macOS'
        run: |
          sudo chown -R `whoami`:admin /usr/local/bin
          sudo chown -R `whoami`:admin /usr/local/share
          sudo chown -R `whoami`:admin /usr/local/opt

      - name: On macOS, Install FFmpeg macOS Dependencies & macdylibbundler for packaging
        if: runner.os == 'macOS'
        run: |
          # Install dependencies needed for both x64 and arm64 builds
          brew install automake git libtool shtool wget nasm dylibbundler

          # Install opus for x64 and arm64
          if [[ "${{ matrix.config.name }}" == "FFmpeg (macOS x64)" ]]; then
            brew install opus
          elif [[ "${{ matrix.config.name }}" == "FFmpeg (macOS arm64)" ]]; then
            echo "Starting cross-compiling libopus for arm64 on macOS..."

            # Download libopus
            VERSION="1.3.1"
            echo "Downloading opus-${VERSION}.tar.gz"
            curl -L "http://downloads.xiph.org/releases/opus/opus-${VERSION}.tar.gz" | tar xz
            cd "opus-${VERSION}"

            # Configure, build, and install libopus
            FLAGS="-arch arm64 -O2 -mmacosx-version-min=11.0 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk"

            ./configure \
              --disable-dependency-tracking \
              --disable-doc \
              --host=arm-apple-darwin \
              CFLAGS="${FLAGS}" \
              LDFLAGS="${FLAGS}" \
              CPPFLAGS="${FLAGS}" \
            && make -j install

            echo "Successfully cross-compiled libopus for arm64 on macOS..."
          fi

      # We disable command-line programs and SDL2 since we have our own SDL2 static build
      - name: On macOS, Configure and Make FFmpeg
        if: runner.os == 'macOS'
        run: |
          if [[ "${{ matrix.config.name }}" == "FFmpeg (macOS x64)" ]]; then
            ./configure \
            --cc=/usr/bin/clang \
            --prefix=@loader_path \
            --libdir=@loader_path \
            --extra-cflags="-O2 -mmacosx-version-min=10.13 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk" \
            --extra-cxxflags="-O2 -mmacosx-version-min=10.13 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk" \
            --extra-ldflags="-mmacosx-version-min=10.13 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk" \
            --enable-libopus \
            --enable-pthreads \
            --enable-shared \
            --disable-programs \
            --disable-doc \
            --disable-debug \
            --disable-sdl2 \
            --disable-static \
            && make -j
          elif [[ "${{ matrix.config.name }}" == "FFmpeg (macOS arm64)" ]]; then
            ./configure \
            --cc=/usr/bin/clang \
            --enable-cross-compile \
            --target-os=darwin \
            --arch=arm64 \
            --pkg-config=pkg-config \
            --prefix=@loader_path \
            --libdir=@loader_path \
            --extra-cflags="-target arm64-apple-macos11 -O2 -mmacosx-version-min=11.0 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk" \
            --extra-cxxflags="-target arm64-apple-macos11 -O2 -mmacosx-version-min=11.0 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk" \
            --extra-ldflags="-target arm64-apple-macos11 -mmacosx-version-min=11.0 -isysroot /Library/Developer/CommandLineTools/SDKs/MacOSX.sdk" \
            --enable-libopus \
            --enable-pthreads \
            --enable-shared \
            --disable-programs \
            --disable-doc \
            --disable-debug \
            --disable-sdl2 \
            --disable-static \
            && make -j
          else
            echo "Unsupported compilation attempt on macOS"
            exit
          fi

      ###################################################################################
      ############################# Ubuntu Linux STEPS START ############################

      - name: On Linux, Build FFmpeg through Docker
        if: runner.os == 'Linux'
        working-directory: .github/workflows/helpers/ffmpeg
        run: ./docker-build.sh 20

      ###################################################################################
      ################################# PUBLISH STEPS START #############################

      # Only publish to AWS S3 on Push/Workflow_dispatch events (code merged into `main`)
      - name: Tar FFmpeg Libs and Upload to AWS S3 (Only on Push Events)
        if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          if [ "$RUNNER_OS" == "Linux" ]; then
            # create protocol-compliant lib folder and move libs over
            mkdir ${{ env.linux-build-folder }}
            mv docker-builds/* ${{ env.linux-build-folder }}/

            # change the linking of our own FFmpeg libs to make them work within the Whist Protocol folder structure
            patchelf --set-rpath '$ORIGIN' ${{ env.linux-build-folder }}/*

            # tar and upload
            tar -zcvf ${{ env.linux-tar-name }} ${{ env.linux-build-folder }}
            aws s3 cp ${{ env.linux-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.linux-tar-name }}
          elif [ "$RUNNER_OS" == "Windows" ]; then
            # cd to the right directory
            cd /c/media-autobuild_suite

            # create protocol-compliant lib folder and rename & move libs over
            mkdir ${{ env.windows-build-folder }}
            mv local64/bin-video/avcodec-59.dll ${{ env.windows-build-folder }}/avcodec-59.dll
            mv local64/bin-video/avdevice-59.dll ${{ env.windows-build-folder }}/avdevice-59.dll
            mv local64/bin-video/avfilter-8.dll ${{ env.windows-build-folder }}/avfilter-8.dll
            mv local64/bin-video/avformat-59.dll ${{ env.windows-build-folder }}/avformat-59.dll
            mv local64/bin-video/avutil-57.dll ${{ env.windows-build-folder }}/avutil-57.dll
            mv local64/bin-video/swresample-4.dll ${{ env.windows-build-folder }}/swresample-4.dll
            mv local64/bin-video/swscale-6.dll ${{ env.windows-build-folder }}/swscale-6.dll
            mv local64/bin-video/avcodec.lib ${{ env.windows-build-folder }}/avcodec.lib
            mv local64/bin-video/avdevice.lib ${{ env.windows-build-folder }}/avdevice.lib
            mv local64/bin-video/avfilter.lib ${{ env.windows-build-folder }}/avfilter.lib
            mv local64/bin-video/avformat.lib ${{ env.windows-build-folder }}/avformat.lib
            mv local64/bin-video/avutil.lib ${{ env.windows-build-folder }}/avutil.lib
            mv local64/bin-video/swresample.lib ${{ env.windows-build-folder }}/swresample.lib
            mv local64/bin-video/swscale.lib ${{ env.windows-build-folder }}/swscale.lib

            # tar and upload
            tar -zcvf ${{ env.windows-tar-name }} ${{ env.windows-build-folder }}
            aws s3 cp ${{ env.windows-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.windows-tar-name }}
          else
            # create staging folder for our dylib bundler to use
            # (important since the bundler expects to resolve between these binaries)
            mkdir dylib-bundle-staging

            # remember to move the versioned libavcodec.58.dylib, for example, not the libavcodec.dylib
            mv lib{av{codec,device,filter,format,util},sw{resample,scale}}/*.*.dylib dylib-bundle-staging

            # create protocol-compliant lib folder to put patched binaries in
            mkdir ${{ env.macos-build-folder }}

            # mark FFmpeg dependencies (fdk-aac, x264, x265, etc.) as executable and change their linking to work with
            # our own FFmpeg libs within the Whist Protocol folder structure
            # note that printf on bash is /usr/bin/printf, which handles the -x poorly by default
            dylibbundler \
              $(printf -- '-x %s ' $(ls dylib-bundle-staging/*.dylib)) \
              -d ${{ env.macos-build-folder }} \
              -p "@loader_path" \
              -b
            mv dylib-bundle-staging/*.dylib ${{ env.macos-build-folder }}
            chmod +x ${{ env.macos-build-folder }}/*.dylib

            # Apple requires all executables to be signed starting with M1 arm64, and the dylibbundler invalidates the
            # existing Homebrew signature for the FFmpeg dependencies, so we re-sign everything. This is not an issue for
            # clientapp deployment, where we re-sign everything, but is necessary for protocol development on M1 macOS.
            codesign -f -v -s "Whist Technologies, Inc." ${{ env.macos-build-folder }}/*.dylib

            if [[ "${{ matrix.config.name }}" == "FFmpeg (macOS x64)" ]]; then
              # tar and upload
              tar -zcvf ${{ env.macos-x64-tar-name }} ${{ env.macos-build-folder }}
              aws s3 cp ${{ env.macos-x64-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.macos-x64-tar-name }}
            elif [[ "${{ matrix.config.name }}" == "macOS (arm64)" ]]; then
              # tar and upload
              tar -zcvf ${{ env.macos-arm64-tar-name }} ${{ env.macos-build-folder }}
              aws s3 cp ${{ env.macos-arm64-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.macos-arm64-tar-name }}
            else
              echo "Tried to tar and upload to S3 for an unsupported OS"
              exit
            fi
          fi

      # Only upload headers once, as they are identical on every OS (on macOS sice version headers don't generate on Linux)
      - name: Tar FFmpeg headers and Upload to AWS S3 (Only on Push Events)
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && matrix.config.name == 'FFmpeg (macOS x64)' }}
        run: |
          # create protocol-compliant headers folder and subfolders
          mkdir -p ${{ env.headers-build-folder }}/{libavcodec,libavdevice,libavfilter,libavformat,libavutil,libswresample,libswscale}

          # move select header files over to tar, only the ones needed
          # libavcodec
          mv \
          libavcodec/ac3_parser.h \
          libavcodec/adts_parser.h \
          libavcodec/avcodec.h \
          libavcodec/avdct.h \
          libavcodec/avfft.h \
          libavcodec/bsf.h \
          libavcodec/codec.h \
          libavcodec/codec_desc.h \
          libavcodec/codec_id.h \
          libavcodec/codec_par.h \
          libavcodec/d3d11va.h \
          libavcodec/dirac.h \
          libavcodec/dv_profile.h \
          libavcodec/dxva2.h \
          libavcodec/jni.h \
          libavcodec/mediacodec.h \
          libavcodec/packet.h \
          libavcodec/qsv.h \
          libavcodec/vaapi_decode.h \
          libavcodec/vaapi_encode.h \
          libavcodec/vaapi_hevc.h \
          libavcodec/vdpau.h \
          libavcodec/version.h \
          libavcodec/videotoolbox.h \
          libavcodec/vorbis_parser.h \
          libavcodec/xvmc.h \
          libavcodec/defs.h \
          ${{ env.headers-build-folder }}/libavcodec/

          # libavdevice
          mv \
          libavdevice/avdevice.h \
          libavdevice/version.h \
          ${{ env.headers-build-folder }}/libavdevice/

          # libavfilter
          mv \
          libavfilter/avfilter.h \
          libavfilter/buffersink.h \
          libavfilter/buffersrc.h \
          libavfilter/vaapi_vpp.h \
          libavfilter/version.h \
          ${{ env.headers-build-folder }}/libavfilter/

          # libavformat
          mv \
          libavformat/avformat.h \
          libavformat/avio.h \
          libavformat/version.h \
          ${{ env.headers-build-folder }}/libavformat/

          # libavutil
          mv \
          libavutil/adler32.h \
          libavutil/aes.h \
          libavutil/aes_ctr.h \
          libavutil/attributes.h \
          libavutil/audio_fifo.h \
          libavutil/avassert.h \
          libavutil/avconfig.h \
          libavutil/avstring.h \
          libavutil/avutil.h \
          libavutil/base64.h \
          libavutil/blowfish.h \
          libavutil/bprint.h \
          libavutil/bswap.h \
          libavutil/buffer.h \
          libavutil/camellia.h \
          libavutil/cast5.h \
          libavutil/channel_layout.h \
          libavutil/common.h \
          libavutil/cpu.h \
          libavutil/crc.h \
          libavutil/des.h \
          libavutil/dict.h \
          libavutil/display.h \
          libavutil/downmix_info.h \
          libavutil/encryption_info.h \
          libavutil/error.h \
          libavutil/eval.h \
          libavutil/fifo.h \
          libavutil/file.h \
          libavutil/frame.h \
          libavutil/hash.h \
          libavutil/hdr_dynamic_metadata.h \
          libavutil/hmac.h \
          libavutil/hwcontext.h \
          libavutil/hwcontext_cuda.h \
          libavutil/hwcontext_d3d11va.h \
          libavutil/hwcontext_drm.h \
          libavutil/hwcontext_dxva2.h \
          libavutil/hwcontext_mediacodec.h \
          libavutil/hwcontext_qsv.h \
          libavutil/hwcontext_vaapi.h \
          libavutil/hwcontext_vdpau.h \
          libavutil/hwcontext_videotoolbox.h \
          libavutil/imgutils.h \
          libavutil/intfloat.h \
          libavutil/intreadwrite.h \
          libavutil/lfg.h \
          libavutil/log.h \
          libavutil/lzo.h \
          libavutil/macros.h \
          libavutil/mastering_display_metadata.h \
          libavutil/mathematics.h \
          libavutil/md5.h \
          libavutil/mem.h \
          libavutil/motion_vector.h \
          libavutil/murmur3.h \
          libavutil/opt.h \
          libavutil/parseutils.h \
          libavutil/pixdesc.h \
          libavutil/pixelutils.h \
          libavutil/pixfmt.h \
          libavutil/random_seed.h \
          libavutil/rational.h \
          libavutil/rc4.h \
          libavutil/replaygain.h \
          libavutil/ripemd.h \
          libavutil/samplefmt.h \
          libavutil/sha.h \
          libavutil/sha512.h \
          libavutil/spherical.h \
          libavutil/stereo3d.h \
          libavutil/tea.h \
          libavutil/threadmessage.h \
          libavutil/time.h \
          libavutil/timecode.h \
          libavutil/timestamp.h \
          libavutil/tree.h \
          libavutil/twofish.h \
          libavutil/tx.h \
          libavutil/version.h \
          libavutil/xtea.h \
          ${{ env.headers-build-folder }}/libavutil/

          # libswresample
          mv \
          libswresample/swresample.h \
          libswresample/version.h \
          ${{ env.headers-build-folder }}/libswresample/

          # libswscale
          mv \
          libswscale/swscale.h \
          libswscale/version.h \
          ${{ env.headers-build-folder }}/libswscale/

          # tar and upload
          tar -zcvf ${{ env.headers-tar-name }} include
          aws s3 cp ${{ env.headers-tar-name }} ${{ env.s3-bucket-uri }}/${{ env.headers-tar-name }}

      ###################################################################################

      - name: Setup Python-based Notifications
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && failure() }}
        working-directory: media-autobuild_suite/build/whist/.github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Notify Slack on Workflow Error (Only on Push/Workflow_dispatch Events)
        if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && failure() }}
        shell: python3 {0}
        run: |
          from notifications.slack_bot import slack_post
          SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          SLACK_CHANNEL = "#alerts-prod"
          BODY = f"@releases :rotating_light: Failed to deploy `${{ matrix.config.name }}` Shared Library to AWS S3, investigate immediately :rotating_light: (<https://github.com/whisthq/FFmpeg/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

  #######################################################################################
  #######################################################################################

  notify-slack:
    name: Notify Slack
    needs:
      [
        build-and-publish-openssl,
        build-and-publish-sentry,
        build-and-publish-ffmpeg,
      ]
    if: ${{ (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && success() }}
    runs-on: ubuntu-20.04
    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3

      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Notify Slack on Success
        shell: python3 {0}
        run: |
          from notifications.slack_bot import slack_post
          SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          TITLE = ":openssl: Whist Protocol Dependencies Deployed :openssl:"
          BODY = f"Whist `FFmpeg`, `Sentry` & `OpenSSL` Libraries deployed to Production via upload to AWS S3 (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)
