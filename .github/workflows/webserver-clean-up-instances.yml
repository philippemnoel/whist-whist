# workflows/webserver-clean-up-instances.yml
#
# Webserver: Clean up Compute Instances
# Peridically scale down surplus compute instances and terminate instances that
# are left over from previous deployments.

name: "Webserver: Clean up Compute Instances"

on:
  schedule:
    # Schedule this Workflow to run every ten minutes. The highest frequency
    # with which we can run our scale-down and and clean-up operatinons is once
    # every five minutes.
    # https://docs.github.com/en/actions/reference/events-that-trigger-workflows#schedule
    - cron: "4/10 * * * *"
  workflow_dispatch:

env:
  TOKEN_FILE: .access_token

jobs:
  # Create a job strategy matrix for the webserver-clean-up-instances job that
  # will cause the following commands to run against each Heroku app in the
  # whist-server pipeline in a one-off dyno:
  #  * flask compute scale-down-instances
  #  * flask compute prune-lingering-instances
  #  * flask compute clean-old-commit-hash-instances
  webserver-clean-up-instances-matrix:
    name: Create Job Matrix
    runs-on: ubuntu-20.04
    outputs:
      environments: ${{ steps.matrix.outputs.environments}}
    steps:
      - name: Get Heroku pipeline info
        id: pipeline
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
        # We don't put quotes around $(...) so the output of the echo command
        # appears on a single line. Omitting the quotation marks causes
        # newlines in the command's output to be treated as delimiters between
        # arguments to the echo command. The echo command prints a space
        # between each of its arguments. Effectively, omitting the quotation
        # marks converts newlines into spaces.
        run: echo ::set-output name=info::$(heroku pipelines:info whist-server --json)

        # The dictionary called lookup maps the names of Heroku apps to the
        # names of deployment environments (e.g. prod, staging). The deployment
        # environment of any Heroku app whose name is not found in the lookup
        # dictionary is set to dev. A deployment environment must be set for
        # each job configuration in the matrix because cached Whist access
        # tokens are associated with specific deployment environments.
      - name: Create instance cleanup matrix
        id: matrix
        shell: python3 {0}
        env:
          APPS: ${{ join(fromJSON(steps.pipeline.outputs.info).apps.*.name, ',') }}
        run: |
          import json
          import os

          heroku_apps = filter(lambda app: "-ci-" not in app and "scaling-service" not in app, os.environ["APPS"].split(","))
          env_mapping = lambda app: {"whist-prod-server": "prod", "whist-staging-server": "staging"}.get(app, "dev")

          environments = [{"app": a, "environment": env_mapping(a)} for a in heroku_apps]
          print(f"::set-output name=environments::{json.dumps(environments)}")

  # Run the following commands against each Heroku app in the whist-server
  # pipeline in a one-off dyno:
  #  * flask compute scale-down-instances
  #  * flask compute prune-lingering-instances
  #  * flask compute clean-old-commit-hash-instances
  webserver-clean-up-instances:
    name: Clean up Compute Instances
    needs: webserver-clean-up-instances-matrix
    runs-on: ubuntu-20.04
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        command:
          - prune-lingering-instances
          - scale-down-instances
          - clean-old-commit-hash-instances
        target: ${{ fromJSON(needs.webserver-clean-up-instances-matrix.outputs.environments) }}
    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v2

      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Format the current date
        id: date
        run: echo ::set-output name=date::$(date -u +%Y%m%d%p)

      - name: Restore cached Whist access token
        uses: actions/cache@v2
        with:
          key: access-token-${{ matrix.target.environment }}-${{ steps.date.outputs.date }}-${{ secrets.cache_salt }}
          path: ${{ env.TOKEN_FILE }}

      - name: Clean up Compute Instances
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
          HEROKU_NOTIFICATIONS: 0
        # $(...) has no effect on the exit status of the entire command list.
        # The first command in the list checks for the existence of the the
        # file containing the access token so we can be sure that the exit
        # status is nonzero if the file does not exist.
        run: >-
          [ -f "$TOKEN_FILE" ] &&
              heroku run --exit-code --env=WHIST_ACCESS_TOKEN="$(cat "$TOKEN_FILE")" --app=${{ matrix.target.app }} -- flask compute ${{ matrix.command }}

      - name: Notify Slack on Failure
        if: failure()
        shell: python3 {0}
        run: |
          from notifications.slack_bot import slack_post

          # Retrieve Slack webhook and channel
          if "prod" in "${{ matrix.app }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ matrix.app }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          BODY = f"@releases :rotating_light: Failed to scale down user EC2 instances, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)
