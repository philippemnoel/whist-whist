# workflows/fractal-publish-build.yml
#
# Fractal: Build & Publish
# Build and publish each of the relevant Fractal projects.

name: "Fractal: Build & Publish"

on:
    push:
        branches:
            - master
            - staging
            - dev
            - project/**
        paths-ignore:
            - "README.md"
            - "**/README.md"
            - ".github/workflows/README.md"
    workflow_dispatch:

jobs:
    # Configure Jobs
    # Detect the branch using regex matching and store as an output to regulate downstream actions.
    # Access branch with `fractal-publish-build-config.outputs.branch`.

    fractal-publish-build-config:
        name: "Configure Jobs"
        runs-on: ubuntu-20.04
        outputs:
            branch: ${{ steps.detect-branch.outputs.branch }}
        steps:
            - name: Detect Branch
              id: detect-branch
              run: |
                  if [[ ${{ github.ref }} =~ ^refs/heads/master$ ]]; then
                      BRANCH_NAME=master
                  elif [[ ${{ github.ref }} =~ ^refs/heads/staging$ ]]; then
                      BRANCH_NAME=staging
                  elif [[ ${{ github.ref }} =~ ^refs/heads/dev$ ]]; then
                      BRANCH_NAME=dev
                  elif [[ ${{ github.ref }} =~ ^refs/heads/project/.*$ ]]; then
                      BRANCH_NAME=project
                  else
                      BRANCH_NAME=null
                  fi
                  echo "branch is $BRANCH_NAME"
                  echo "::set-output name=branch::$BRANCH_NAME"

    # Container Images: Build & Publish Base Image to AWS ECR
    # Build and publish the base image to the placeholder region, so that parallel build
    #   processes can build and publish everything on top of base.
    # Runs if config succeeds and branch is in ["master"].

    container-images-publish-base-image-ecr:
        name: "Container Images: Build & Push Publish Image to AWS ECR"
        runs-on: ubuntu-20.04
        outputs:
            task-definitions-matrix: ${{ steps.package-matrix.outputs.task-definitions-matrix }}
        needs: [fractal-publish-build-config]
        if: contains(fromJSON('["master"]'), needs.fractal-publish-build-config.outputs.branch)
        env:
            aws-placeholder-region: us-east-1
            aws-regions: >
                us-east-1
                us-west-1
                ca-central-1
            # disabled us-east-2 and us-west-2 for the time being
        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2
              with:
                  persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal token
                  token: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
                  submodules: recursive

            - name: Configure AWS CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_ECR_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_ECR_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.aws-placeholder-region }}

            - name: Build release protocol # No need to run this for debug, just for release
              run: ./protocol/build_protocol.sh release

            - name: Build base container images
              run: ./container-images/build_container_image.sh base

            - name: Push base container image to placeholder region
              run: ./container-images/push_container_image.sh base ${{ env.aws-placeholder-region }}

            - name: Walk repo to find all dockerfiles and store path as env variable
              run: echo "apps=$(./container-images/find_images_in_git_repo.sh)" >> $GITHUB_ENV

            - name: Package app names and regions into json for container-images and ecs-task-definitions strategy matrices
              id: package-matrix
              run: |
                  matrix='{"aws-region": [], "app": []}'
                  for region in ${{ env.aws-regions }}
                  do
                    matrix=$(echo $matrix | jq -c ".\"aws-region\" += [\"$region\"]")
                  done

                  for app in ${{ env.apps }}
                  do
                    matrix=$(echo $matrix | jq -c ".\"app\" += [\"fractal/$app\"]")
                  done

                  echo "::set-output name=task-definitions-matrix::$matrix"

    # Container Images: Build & Publish to AWS ECR
    # Build and publish the container images to an ECR repository from which the EC2 instance pull,
    #   for every region.
    # Runs if container-images-publish-base-image-ecr succeeds.

    container-images-publish-images-ecr:
        name: "Container Images: Build & Publish ${{ matrix.app }} to AWS ECR"
        runs-on: ubuntu-20.04
        needs: [container-images-publish-base-image-ecr]

        strategy:
            matrix: ${{ fromJSON(needs.container-images-publish-base-image-ecr.outputs.task-definitions-matrix) }}

        env:
            aws-placeholder-region: us-east-1

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2
              with:
                  persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal token
                  token: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
                  submodules: recursive

            - name: Configure AWS CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_ECR_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_ECR_SECRET_ACCESS_KEY }}
                  aws-region: ${{ matrix.aws-region }}

            - name: Build container image over base from placeholder region
              run: ./container-images/build_container_image_from_base.sh ${{ env.aws-placeholder-region }} ${{ matrix.app }}

            - name: Push container image
              run: ./container-images/push_container_image.sh ${{ matrix.app }} ${{ matrix.aws-region }}

            - name: Create Lifecycle Policies for image, only keeps latest 10
              run: ./container-images/apply_acr_lifecycle_policy.sh ${{ matrix.app }} ${{ matrix.aws-region }}

    # Container Images: Notify Slack
    # Notify Slack after building and pushing all the container images.
    # Runs if publish-images-ecr succeeds.

    container-images-notify-slack:
        name: "Container Images: Notify Slack"
        needs: [container-images-publish-images-ecr]
        if: success()
        runs-on: ubuntu-20.04
        steps:
            - name: Notify Slack
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":whale: Container images builds pushed to production via Docker push to ECR :bezos:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # ECS Host Service: Build & Publish to AWS S3
    # Build and publish the ECS host service to an S3 bucket from which EC2 hosts pull.
    # Runs if config succeeds and branch is in ["master"] and publish-images-ecr succeeds.

    ecs-host-service-publish-build-s3:
        name: "ECS Host Service: Build & Publish to AWS S3"
        runs-on: ubuntu-20.04
        needs:
            [fractal-publish-build-config, container-images-publish-images-ecr]
        if: contains(fromJSON('["master"]'), needs.fractal-publish-build-config.outputs.branch)
        env:
            binary-location: ecs-host-service/build
            binary-name: ecs-host-service
            s3-bucket-region: us-east-1 # eventually, we should replicate s3 per region
            s3-bucket-uri: s3://fractal-ecs-host-service

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2
              with:
                  persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal token
                  fetch-depth: 0 # otherwise, you will fail to push refs to dest repo

            - name: Setup Go environment
              uses: actions/setup-go@v2.1.3

            - name: Configure AWS CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.s3-bucket-region }}

            - name: Install Go dependencies
              run: cd ecs-host-service && make deps

            - name: Build Go project
              env:
                  WEBSERVER_AUTH_SECRET_DEV: ${{ secrets.HOST_SERVICE_AND_WEBSERVER_AUTH_SECRET_DEV }}
                  WEBSERVER_AUTH_SECRET_STAGING: ${{ secrets.HOST_SERVICE_AND_WEBSERVER_AUTH_SECRET_STAGING }}
                  WEBSERVER_AUTH_SECRET_PROD: ${{ secrets.HOST_SERVICE_AND_WEBSERVER_AUTH_SECRET_PROD }}
              run: cd ecs-host-service && make build

            - name: Upload binary to S3
              run: aws s3 cp ${{ env.binary-location }}/${{ env.binary-name }} ${{ env.s3-bucket-uri }}/${{ env.binary-name }}

            - name: Notify Slack
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":athletic_shoe: ECS Host Service build pushed to production via S3 upload :bezos:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # ECS Task Definitions: Render & Deploy Task Definitions to ECS
    # Render and deploy the app task definitions to ECS.
    # Runs if config succeeds and branch is in ["master"] and publish-images-ecr succeeds.

    ecs-task-definitions-deploy-task-definitions-ecs:
        name: "ECS Task Definitions: Render & Deploy Task Definitions to ECS"
        runs-on: ubuntu-20.04
        needs:
            [fractal-publish-build-config, container-images-publish-images-ecr]
        if: contains(fromJSON('["master"]'), needs.fractal-publish-build-config.outputs.branch)

        strategy:
            matrix: ${{ fromJSON(needs.container-images-publish-base-image-ecr.outputs.task-definitions-matrix) }}

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2
              with:
                  persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal token
                  fetch-depth: 0 # otherwise, you will fail to push refs to dest repo

            - name: Configure AWS CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_ECS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_ECS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ matrix.aws-region }}

            # TODO: this can be done way more elegantly, now that it's a monorepo
            - name: Retrieve master git hash as env variable
              run: echo "containers_gha_sha=$(git ls-remote https://${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}@github.com/fractal/fractal | head -1 | sed 's/HEAD//')" >> $GITHUB_ENV

            - name: Retrieve AWS account number as env variable
              run: echo "aws_account=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_ENV

            - name: Store AWS ECR base uri as env variable
              run: echo "ecr_base_uri=${{ env.aws_account }}.dkr.ecr.${{ matrix.aws-region }}.amazonaws.com" >> $GITHUB_ENV

            - name: Store taskdef name as env variable
              run: echo "taskdef_name=$(echo ${{ matrix.app }} | tr / -)" >> $GITHUB_ENV

            - name: Generate taskdef and store JSON path to variable
              working-directory: ecs-task-definitions
              run: |
                  taskdef_json_filename=$(./generate-taskdef.sh $taskdef_name)
                  echo "taskdef_json=ecs-task-definitions/$taskdef_json_filename" >> $GITHUB_ENV

            - name: Render Amazon ECS task Definitions
              id: render-web-container
              uses: aws-actions/amazon-ecs-render-task-definition@v1
              with:
                  container-name: fractal-container
                  task-definition: ${{ env.taskdef_json }}
                  image: ${{ env.ecr_base_uri }}/${{ matrix.app }}:${{ env.containers_gha_sha }}

            - name: Deploy to Amazon ECS service
              uses: aws-actions/amazon-ecs-deploy-task-definition@v1
              with:
                  task-definition: ${{ steps.render-web-container.outputs.task-definition }}

    # ECS Task Definitions: Notify Slack
    # Notify Slack after rendering and deploying all the task definitions.
    # Runs if deploy-task-definitions-ecs succeeds.

    ecs-task-definitions-notify-slack:
        name: "ECS Task Definitions: Notify Slack"
        needs: [ecs-task-definitions-deploy-task-definitions-ecs]
        if: success()
        runs-on: ubuntu-20.04
        steps:
            - name: Notify Slack
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":spiral_note_pad: Task Definitions rendered and deployed to production via ECS upload :bezos:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # Main Webserver: Deploy to Heroku
    # Push the main-webserver subtree to the appropriate Heroku app.
    # Runs if config succeeds and branch is in ["master"] and publish-images-ecr succeeds, or unconditionally if branch is in ["dev"] (since other workflows won't run then)

    main-webserver-deploy-heroku:
        name: "Main Webserver: Deploy to Heroku"
        needs:
            [fractal-publish-build-config, container-images-publish-images-ecr]
        if: |
            ( 
                contains(
                    fromJSON('["master"]'), 
                    needs.fractal-publish-build-config.outputs.branch
                ) && success()
            ) || 
            (
                contains(
                    fromJSON('["dev"]'),
                    needs.fractal-publish-build-config.outputs.branch
                ) && always()
            )
        runs-on: ubuntu-20.04
        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2
              with:
                  persist-credentials: false # otherwise, the token used is the GITHUB_TOKEN, instead of your personal token
                  fetch-depth: 0 # otherwise, you will fail to push refs to dest repo

            - name: Authenticate Heroku
              run: |
                  cat > ~/.netrc << EOF
                  machine api.heroku.com
                    login ${{ secrets.HEROKU_DEVELOPER_LOGIN_EMAIL }}
                    password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
                  machine git.heroku.com
                    login ${{ secrets.HEROKU_DEVELOPER_LOGIN_EMAIL }}
                    password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
                  EOF

            - name: Add Heroku Remote
              run: |
                  if [[ ${{ needs.fractal-publish-build-config.outputs.branch }} == dev ]]; then
                      HEROKU_APP_NAME=fractal-dev-server
                  elif [[ ${{ needs.fractal-publish-build-config.outputs.branch }} == master ]]; then
                      HEROKU_APP_NAME=fractal-staging-server
                  else
                      echo 'Error: Invalid branch' && false
                  fi
                  echo "HEROKU_APP_NAME=$HEROKU_APP_NAME" >> $GITHUB_ENV

                  heroku git:remote --app $HEROKU_APP_NAME --remote heroku-fractal-server
              env:
                  HEROKU_API_KEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}

            - name: Split off and checkout main-webserver subtree
              run: |
                  git subtree split --prefix main-webserver -b workflows-private/main-webserver
                  git checkout workflows-private/main-webserver

            - name: Push to Heroku remote, deploying the app # force push is only necessary for the transition period, then should be removed
              run: |
                  git push -f heroku-fractal-server workflows-private/main-webserver:master

            - name: Notify Slack
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":rocket: Main webserver for branch \`${{ needs.fractal-publish-build-config.outputs.branch }}\` deployed to Heroku app \`$HEROKU_APP_NAME\` :heroku:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}
