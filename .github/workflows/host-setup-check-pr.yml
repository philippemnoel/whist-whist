# workflows/host-setup-check-pr.yml
#
# Host Setup: Check PR
# Checks an Host Setup PR for AMI building success with Packer.

name: "Host Setup: Check PR"

on:
  pull_request:
    paths:
      - "host-setup/**"
      - "!host-setup/README.md"
      - ".github/workflows/host-setup-check-pr.yml"
  workflow_dispatch:

jobs:
  # Building
  # Check that the AMIs build
  host-setup-check-pr-building:
    name: Building
    runs-on: ubuntu-20.04
    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3

      - name: Set up Python 3.10.0
        uses: actions/setup-python@v3.0.0
        with:
          python-version: "3.10.0"

      ########################## Building Backend Services ######################

      - name: Setup Go environment
        uses: actions/setup-go@v3.0.0
        with:
          go-version: "1.17"

      - name: Authenticate Go Commands with GitHub
        env:
          GH_USERNAME: ${{ secrets.GHA_USERNAME }}
          GH_PAT: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
        run: git config --global url.https://$GH_USERNAME:$GH_PAT@github.com/.insteadOf https://github.com/

      - name: Build Backend Services
        working-directory: backend/services
        env:
          HEROKU_USER: developers@whist.com
          HEROKU_APIKEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
        run: make build

      ###########################################################################
      ############################## Building AMIs ##############################

      - name: Configure AWS CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set Host Service APP_ENV based to DEV (File gets read by host-service.service)
        working-directory: host-setup
        run: echo 'APP_ENV=DEV' > app_env.env

      # This spins up an AWS EC2 instance to create the AMI, and then deletes it
      # It *could* fail if we are maxed-out in number AWS vCPUs allowed in the source region, us-east-1
      - name: Generate Packer Configuration and Create New AMI
        working-directory: host-setup
        shell: python3 {0}
        run: |
          import os, json, datetime, subprocess

          # Get the current date and time
          date_str = datetime.datetime.utcnow().strftime("%Y-%m-%d-%H-%M-%S")

          # Generate the Packer configuration variables
          # We hardcode the git_hash and git_branch name of pre-built Chrome/Brave mandelbox images stored in
          # GHCR to be able to test AMIs without needing to build and deploy new mandelboxes

          data = {}
          data["github_pat"] = "${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}"
          data["github_username"] = "${{ secrets.GHA_USERNAME }}"
          data["git_branch"] = "dev"
          data["git_hash"] = "88c656033c927e10337cf1c00bb0e73359929ecd"
          data["pr_number"] = "${{ github.event.number }}" # Used to identify the Packer test instance we create
          data["access_key"] = "${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}"
          data["secret_key"] = "${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}"
          data["ami_name"] = f"whist-test-ami-${{ github.sha }}-{date_str}"
          data["mandelbox_logz_shipping_token"] = "${{ secrets.LOGZ_SHIPPING_TOKEN_DEV }}"

          # For testing, we only clone our new AMI  to one region, us-east-1, to save time in CI. In deployments,
          # data["destination_regions"] should be a list of all regions we support, defined as a string of comma-separated
          # values (no spaces) as required by Packer
          data["destination_regions"] = ["us-east-1"]

          # Packer isn't able to loop over Availability Zones (AZes) by itself. This means that if we specify
          # us-east-1 as the region (which has availability zones `a` through `f`), Packer will randomly
          # pick one and attempt to run there, failing if there is no capacity in that AZ (even if there
          # is capacity in other AZes). To work around this, we need to loop over all AZs ourselves, until
          # one of them has capacity (only returning an error if there is no capacity in any of the AZes).
          # We go alphabetically, since earlier AZes are larger and more likely to have capacity.
          for a_zone in ["us-east-1a", "us-east-1b", "us-east-1c", "us-east-1d", "us-east-1e", "us-east-1f"]:
            data["availability_zone"] = a_zone

            # Write the generated Packer variables to a file
            fp = open("packer_vars.json", "w")
            json.dump(data, fp)
            fp.close()

            # Display file content, for debugging purposes
            subprocess.run("cat packer_vars.json && echo '\n\n'", shell=True)

            # Validate the Packer variables file for syntax errors
            subprocess.run("packer validate -var-file=packer_vars.json ami_config.pkr.hcl && echo '\n\n'", shell=True)

            # Generate AMIs via Packer
            # Stdout will be shared with the subprocess so that we can see what is happening
            # If you need to debug Packer, add `PACKER_LOG=1` before `packer build ...` in the subprocess.run command
            subprocess.run("packer build -var-file=packer_vars.json ami_config.pkr.hcl", shell=True)

            # If Packer succeeds, it will create `manifest.json`, which is our cue to stop trying other AZes
            if os.path.exists("manifest.json"):
              print("Packer succeeded, exiting availability zones loop...")
              break
            
          # Assert that `manifest.json` exists after looping over all AZes to fail the workflow in the event that 
          # we couldn't get capacity in any of the availability zones
          assert os.path.exists("manifest.json")

          # Print Packer output for debugging purposes, since this data is used in the next step of the 
          # deploy stage, in `whist-build-and-deploy.yml`
          fp = open("manifest.json", "r")
          data = json.load(fp)
          fp.close()
          print("Printing Packer output: " + str(data))

      ###########################################################################
