# workflows/host-setup-check-pr.yml
#
# Host Setup: Check PR
# Checks an Host Setup PR for AMI building success with Packer.

name: "Host Setup: Check PR"

on:
  pull_request:
    paths:
      - "host-setup/**"
      - "!host-setup/README.md"
      - ".github/workflows/host-setup-check-pr.yml"
  workflow_dispatch:

jobs:
  # Building
  # Check that the AMIs build
  host-setup-check-pr-building:
    name: Building
    runs-on: [self-hosted, linux, x64, t3.xlarge]
    env:
      aws_new_ami_source_region: us-east-1 # The AWS region our new AMI gets built in, we pick a region that's not very used to avoid "insufficient capacity" issues
      aws_new_ami_instance_type: g4dn.xlarge # The AWS EC2 instance type our new AMI gets built on (must be the EC2 instance type we run in production)
      aws_new_ami_vpc_id: vpc-34aded4e # The ID of the Whist-created VPC the EC2 instance building the AMI is part of
      aws_source_ami_id: ami-0885b1f6bd170450c # The base AWS-provided AMI we build our AMI from (AWS Ubuntu Server 20.04 LTS) associated with the aws_new_ami_source_region

    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v2

      - name: Set up Python 3.10.0
        uses: actions/setup-python@v2.3.0
        with:
          python-version: "3.10.0"

      ########################## Building Host Service ##########################

      # To build Host Service
      - name: Setup Go environment
        uses: actions/setup-go@v2.1.3
        with:
          go-version: "1.17"

      - name: Authenticate Go Commands with GitHub
        env:
          GH_USERNAME: ${{ secrets.GHA_USERNAME }}
          GH_PAT: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
        run: git config --global url.https://$GH_USERNAME:$GH_PAT@github.com/.insteadOf https://github.com/

      - name: Build Go Project
        working-directory: host-service
        env:
          HEROKU_USER: developers@whist.com
          HEROKU_APIKEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
        run: make build

      ###########################################################################
      ############################## Building AMIs ##############################

      - name: Configure AWS CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.aws_new_ami_source_region }}

      - name: Set Host Service APP_ENV based to DEV (File gets read by host-service.service)
        working-directory: host-setup
        run: echo 'APP_ENV=DEV' > app_env.env

      - name: Generate packer_vars.json Packer Variables File for Building New AMI
        working-directory: host-setup
        shell: python3 {0}
        run: |
          import json
          import datetime

          # we hardcode the git_hash and git_branch name of pre-built Chrome/Brave mandelbox images stored in
          # GHCR to be able to test AMIs without needing to build and deploy new mandelboxes

          data = {}
          data["github_pat"] = "${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}"
          data["github_username"] = "${{ secrets.GHA_USERNAME }}"
          data["git_branch"] = "dev"
          data["git_hash"] = "e885ddd98fd5d02841435592a6cb191321a53d24"

          # pr_number is the number of the pr this check is running for,
          # used to identify the Packer instance we create
          data["pr_number"] = "${{ github.event.number }}"
          data["secret_key"] = "${{ secrets.AWS_EC2_SECRET_ACCESS_KEY}}"
          data["access_key"] = "${{ secrets.AWS_EC2_ACCESS_KEY_ID }}"
          date_str = datetime.datetime.utcnow().strftime("%Y-%m-%d-%H-%M-%S")
          data["ami_name"] = f"whist-test-ami-${{ github.sha }}-{date_str}"
          data["source_region"] = "${{ env.aws_new_ami_source_region }}"
          data["instance_type"] = "${{ env.aws_new_ami_instance_type }}"
          data["vpc_id"] = "${{ env.aws_new_ami_vpc_id }}"
          data["source_ami"] = "${{ env.aws_source_ami_id }}"
          data["mandelbox_logz_shipping_token"] = "${{ secrets.LOGZ_SHIPPING_TOKEN_DEV }}"

          # The regions our new AMI gets cloned to (Only us-east-1 for testing, as cloning takes some time)
          # defined as a string of comma-separated values (no spaces) as required by Packer.
          data["destination_regions"] = ["us-east-1"]
          fp = open("packer_vars.json", "w")
          json.dump(data, fp)
          fp.close()

      # This spins up an AWS EC2 instance to create the AMI, and then deletes it
      # It *could* fail if we are maxed-out in number AWS vCPUs allowed in aws_new_ami_source_region
      - name: Create New AMI in aws_new_ami_source_region via Packer
        working-directory: host-setup
        shell: python3 {0}
        run: |
          import os
          import subprocess
          import json

          retry_count = 0
          while not os.path.exists("manifest.json") and retry_count < 5:
            retry_count += 1
            # stdout will be shared with the subprocess so we can see what is happening
            subprocess.run("packer build -var-file=packer_vars.json ami_config.pkr.hcl", shell=True)

            # If Packer fails, manifest.json does not get created. We retry up to 5 times, as we may 
            # face InsufficientCapacity issues from AWS, which typically get resolved via retrying after
            # waiting up to 200 seconds.

          # Print Packer output for debugging visibility, since this data is used in the next step of the 
          # deploy stage, in `whist-build-and-deploy.yml`
          fp = open("manifest.json", "r")
          data = json.load(fp)
          fp.close()
          print(data)

      ###########################################################################
