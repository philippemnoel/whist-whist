# workflows/fractal-publish-build.yml
#
# Fractal: Build & Publish
# Build and publish each of the relevant Fractal projects.

name: "Fractal: Build & Deploy"

on:
    push:
        branches:
            - master
            - staging
            - dev
            - project/**
        paths-ignore:
            - "README.md"
            - "**/README.md"
            - ".github/workflows/README.md"
    workflow_dispatch:
        inputs:
            job-name:
                description: "Name of the job to trigger, or 'all' to trigger all jobs."
                required: true
                default: "None" # Avoid accidental mistakes by making the default not run any jobs
            publish:
                description: "'true' if the job(s) being run should publish, or 'false' to do a test run without publishing"
                required: true
                default: false # Avoid accidental mistakes by making the default not publish

jobs:
    # Configure Jobs
    # Detect the branch using regex matching and store as an output to regulate downstream actions.
    # Access branch with `fractal-publish-build-config.outputs.branch`.
    fractal-publish-build-config:
        name: "Configure Jobs"
        runs-on: ubuntu-20.04
        outputs:
            branch: ${{ steps.detect-branch.outputs.branch }}
            job: ${{ steps.detect-job.outputs.job }}
            publish: ${{ steps.detect-publish.outputs.publish }}
        steps:
            - name: Detect Branch
              id: detect-branch
              run: |
                  if [[ ${{ github.ref }} =~ ^refs/heads/master$ ]]; then
                      BRANCH_NAME=master
                  elif [[ ${{ github.ref }} =~ ^refs/heads/staging$ ]]; then
                      BRANCH_NAME=staging
                  elif [[ ${{ github.ref }} =~ ^refs/heads/dev$ ]]; then
                      BRANCH_NAME=dev
                  elif [[ ${{ github.ref }} =~ ^refs/heads/project/.*$ ]]; then
                      BRANCH_NAME=project
                  else
                      BRANCH_NAME=null
                  fi
                  echo "branch is set to: $BRANCH_NAME"
                  echo "::set-output name=branch::$BRANCH_NAME"

            - name: Detect Job(s)
              id: detect-job
              run: |
                  # if running from workflow_dispatch, a job-name will be set, so we set it as environment variable
                  # if running from push, no job-name will be set and JOB_NAME will be empty
                  JOB_NAME=${{ github.event.inputs.job-name }}

                  # if JOB_NAME is empty, this workflow was triggered by push, so we want to run all jobs
                  if [[ -z $JOB_NAME && ${{ github.event_name }} == 'push' ]]; then
                    JOB_NAME=all
                  fi

                  echo "Job is set to: $JOB_NAME"
                  echo "::set-output name=job::$JOB_NAME"

            - name: Detect Whether to Publish the Job(s) or Not
              id: detect-publish
              run: |
                  # if running from workflow_dispatch, publish will be set, so we set it as environment variable
                  # if running from push, publish will not be set and PUBLISH will be empty
                  PUBLISH=${{ github.event.inputs.publish }}

                  # if PUBLISH is empty, this workflow was triggered by push, so we want to publish all jobs
                  if [[ -z $PUBLISH && ${{ github.event_name }} == 'push' ]]; then
                    PUBLISH=true
                  fi

                  echo "Publish is set to: $PUBLISH"
                  echo "::set-output name=publish::$PUBLISH"

    # Container Images: Build & Publish to GitHub Container Registry
    # Build and publish the container images to a GitHub Container Registry repository
    # Runs if config succeeds and branch is in ["master"].
    container-images-publish-images-ghcr:
        name: "Container Images: Build & Publish Images to GitHub Container Registry"
        runs-on: ubuntu-20.04
        needs: [fractal-publish-build-config]
        outputs:
            task-definitions-apps-json: ${{ steps.package-matrix.outputs.task-definitions-apps-json }}
        if: >
            contains(fromJSON('["master"]'), needs.fractal-publish-build-config.outputs.branch) &&
            contains(fromJSON('["all", "container-images-publish-images-ghcr"]'), needs.fractal-publish-build-config.outputs.job)
        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2

            - name: Configure AWS CLI # To get and install GRID driver
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
                  aws-region: us-east-1

            - name: Walk repo to find all dockerfiles and store path as env variable
              run: echo "apps=$(./container-images/find_images_in_git_repo.sh)" >> $GITHUB_ENV

            - name: Build release protocol # No need to run this for debug, just for release
              working-directory: protocol
              run: ./build_protocol.sh release

            - name: Build container images
              working-directory: container-images
              run: |
                  for app in ${{ env.apps }}
                  do
                    ./build_container_image.sh $app
                  done

            - name: Push container images
              working-directory: container-images
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: |
                  for app in ${{ env.apps }}
                  do
                    ./push_container_image.sh $app
                  done
              env:
                  GH_USERNAME: ${{ secrets.GHA_USERNAME }}
                  GH_PAT: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}

            - name: Package app names into JSON for ecs-task-definitions strategy matrices
              id: package-matrix
              run: |
                  apps_json='[]'

                  for app in ${{ env.apps }}
                  do
                    apps_json=$(echo $apps_json | jq -c ". += [\"$app\"]")
                  done

                  echo "::set-output name=task-definitions-apps-json::$apps_json"

            - name: Notify Slack
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":whale: Container images builds pushed to production via Docker push to GitHub Container Registry :github:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # ECS Task Definitions: Render & Deploy Task Definitions to ECS
    # Render and deploy the app task definitions to ECS.
    # Runs if config succeeds and branch is in ["master"] and publish-images-ghcr succeeds.
    ecs-task-definitions-deploy-task-definitions-ecs:
        name: "ECS Task Definitions: Render & Deploy Task Definitions to ECS"
        runs-on: ubuntu-20.04
        needs:
            [fractal-publish-build-config, container-images-publish-images-ghcr]
        if: >
            contains(fromJSON('["master"]'), needs.fractal-publish-build-config.outputs.branch) &&
            contains(fromJSON('["all", "ecs-task-definitions-deploy-task-definitions-ecs"]'), needs.fractal-publish-build-config.outputs.job)

        strategy:
            matrix:
                app: ${{ fromJSON(needs.container-images-publish-images-ghcr.outputs.task-definitions-apps-json) }}
                aws-region:
                    - us-east-1
                    - us-east-2
                    - us-west-1
                    - us-west-2
                    - ca-central-1
                    - eu-west-1
                    - eu-central-1

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2

            - name: Configure AWS CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_ECS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_ECS_SECRET_ACCESS_KEY }}
                  aws-region: ${{ matrix.aws-region }}

            - name: Retrieve master git hash as env variable
              run: echo "containers_gha_sha=$(git rev-parse HEAD)" >> $GITHUB_ENV

            - name: Store GitHub Container Registry base URI as env variable
              run: echo "ghcr_base_uri=ghcr.io" >> $GITHUB_ENV

            - name: Store taskdef name as env variable
              run: echo "taskdef_name=$(echo fractal/${{ matrix.app }} | tr / -)" >> $GITHUB_ENV

            - name: Generate taskdef and store JSON path to variable
              working-directory: ecs-task-definitions
              run: |
                  taskdef_json_filename=$(./generate-taskdef.sh $taskdef_name)
                  echo "taskdef_json=ecs-task-definitions/$taskdef_json_filename" >> $GITHUB_ENV

            - name: Render Amazon ECS task Definitions
              id: render-web-container
              uses: aws-actions/amazon-ecs-render-task-definition@v1
              with:
                  container-name: fractal-container
                  task-definition: ${{ env.taskdef_json }}
                  image: ${{ env.ghcr_base_uri }}/fractal/${{ matrix.app }}:${{ env.containers_gha_sha }}

            - name: Deploy to Amazon ECS service
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              uses: aws-actions/amazon-ecs-deploy-task-definition@v1
              with:
                  task-definition: ${{ steps.render-web-container.outputs.task-definition }}

    # ECS Task Definitions: Notify Slack
    # Notify Slack after rendering and deploying all the task definitions.
    # Runs if deploy-task-definitions-ecs succeeds.
    ecs-task-definitions-notify-slack:
        name: "ECS Task Definitions: Notify Slack"
        needs: [ecs-task-definitions-deploy-task-definitions-ecs]
        if: >
            success() &&
            contains(fromJSON('["all", "ecs-task-definitions-deploy-task-definitions-ecs"]'), needs.fractal-publish-build-config.outputs.job)
        runs-on: ubuntu-20.04
        steps:
            - name: Notify Slack
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":spiral_note_pad: Task Definitions rendered and deployed to production via ECS upload :bezos:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # ECS Host Service: Build & Publish to AWS S3
    # Build and publish the ECS host service to an S3 bucket from which EC2 hosts pull.
    # Runs if config succeeds and branch is in ["master"] and publish-images-ghcr succeeds.
    ecs-host-service-publish-build-s3:
        name: "ECS Host Service: Build & Publish to AWS S3"
        runs-on: ubuntu-20.04
        needs:
            [fractal-publish-build-config, container-images-publish-images-ghcr]
        if: >
            contains(fromJSON('["master"]'), needs.fractal-publish-build-config.outputs.branch) &&
            contains(fromJSON('["all", "ecs-host-service-publish-build-s3"]'), needs.fractal-publish-build-config.outputs.job)
        env:
            binary-location: ecs-host-service/build
            binary-name: ecs-host-service
            s3-bucket-region: us-east-1
            s3-bucket-uri: s3://fractal-ecs-host-service

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2

            - name: Setup Go environment
              uses: actions/setup-go@v2.1.3

            - name: Configure AWS CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
                  aws-region: ${{ env.s3-bucket-region }}

            - name: Install Go dependencies
              working-directory: ecs-host-service
              run: make deps

            - name: Build Go project
              env:
                  WEBSERVER_AUTH_SECRET_DEV: ${{ secrets.HOST_SERVICE_AND_WEBSERVER_AUTH_SECRET_DEV }}
                  WEBSERVER_AUTH_SECRET_STAGING: ${{ secrets.HOST_SERVICE_AND_WEBSERVER_AUTH_SECRET_STAGING }}
                  WEBSERVER_AUTH_SECRET_PROD: ${{ secrets.HOST_SERVICE_AND_WEBSERVER_AUTH_SECRET_PROD }}
              working-directory: ecs-host-service
              run: make build

            - name: Upload binary to S3
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: aws s3 cp ${{ env.binary-location }}/${{ env.binary-name }} ${{ env.s3-bucket-uri }}/${{ env.binary-name }}

            - name: Notify Slack
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":athletic_shoe: ECS Host Service build pushed to production via S3 upload :bezos:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}



    ## TODO(phil) ^^^ all the way up from here: implement staging/dev -- currently waiting on automated AMI to avoid duplicating work



    # Main Webserver: Deploy to Heroku
    # Push the main-webserver subtree to the appropriate Heroku app.
    # Runs if config succeeds and branch is in ["staging", "master"] and publish-images-ghcr succeeds, or unconditionally if branch is in ["dev"] (since other workflows won't run then)

    main-webserver-deploy-heroku:
        name: "Main Webserver: Deploy to Heroku"
        runs-on: ubuntu-20.04
        needs:
            [fractal-publish-build-config, container-images-publish-images-ghcr]
        if: >
            (
              (
                contains(
                  fromJSON('["master"]'),
                  needs.fractal-publish-build-config.outputs.branch
                ) && success()
              ) ||
              (
                contains(
                  fromJSON('["staging", "dev"]'),
                  needs.fractal-publish-build-config.outputs.branch
                ) && always()
              )
            ) && contains(fromJSON('["all"], ["main-webserver-deploy-heroku"]'), needs.fractal-publish-build-config.outputs.job)

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2
              with:
                  fetch-depth: 0 # need to get full history for splitsh-lite

            - name: Authenticate Heroku
              run: |
                  cat > ~/.netrc << EOF
                  machine api.heroku.com
                    login ${{ secrets.HEROKU_DEVELOPER_LOGIN_EMAIL }}
                    password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
                  machine git.heroku.com
                    login ${{ secrets.HEROKU_DEVELOPER_LOGIN_EMAIL }}
                    password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
                  EOF

            - name: Add Heroku Remote
              run: |
                  if [[ ${{ needs.fractal-publish-build-config.outputs.branch }} == dev ]]; then
                      HEROKU_APP_NAME=fractal-dev-server
                  elif [[ ${{ needs.fractal-publish-build-config.outputs.branch }} == staging ]]; then
                      HEROKU_APP_NAME=fractal-staging-server
                  elif [[ ${{ needs.fractal-publish-build-config.outputs.branch }} == master ]]; then
                      HEROKU_APP_NAME=fractal-prod-server
                  else
                      echo 'Error: Invalid branch' && false
                  fi
                  echo "HEROKU_APP_NAME=$HEROKU_APP_NAME" >> $GITHUB_ENV

                  heroku git:remote --app $HEROKU_APP_NAME --remote heroku-fractal-server
              env:
                  HEROKU_API_KEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}

            - name: Install splitsh-lite for Subtree Split
              run: >
                  wget -qO - https://github.com/splitsh/lite/releases/download/v1.0.1/lite_linux_amd64.tar.gz
                  | sudo tar -zxp --directory /usr/local/bin/

            - name: Split off and checkout main-webserver subtree
              run: |
                  splitsh-lite --prefix main-webserver --target refs/heads/workflows-private/main-webserver
                  git checkout workflows-private/main-webserver

            - name: Push to Heroku remote, deploying the app # force push is only necessary for the transition period, then should be removed
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: git push -f heroku-fractal-server workflows-private/main-webserver:master

            - name: Notify Slack
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \":rocket: Webserver for branch \`${{ needs.fractal-publish-build-config.outputs.branch }}\` deployed to Heroku app \`$HEROKU_APP_NAME\` :heroku:\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}

    # Client Applications: Build & Publish to AWS S3
    # Build and publish the client applications to their respective AWS S3 bucket,
    # from which Electron-Updater pulls them for auto-updating
    # Runs if config succeeds and branch is in ["master"] and all previous publish jobs succeed
    client-applications-publish-build-s3:
        name: "Client Applications: Build & Publish ${{ matrix.config.name }}"
        runs-on: ${{ matrix.config.os }}
        needs:
            [
                fractal-publish-build-config,
                container-images-publish-images-ghcr,
                ecs-task-definitions-deploy-task-definitions-ecs,
                ecs-host-service-publish-build-s3,
                main-webserver-deploy-heroku,
            ]
        if: >
            contains(fromJSON('["master"]'), needs.fractal-publish-build-config.outputs.branch) &&
            contains(fromJSON('["all", "client-applications-publish-build-s3"]'), needs.fractal-publish-build-config.outputs.job)

        strategy:
            matrix:
                config:
                    - name: "Windows Desktop Application"
                      os: windows-2016 # cmake is pre-installed on windows-2016+ GHA machines
                    - name: "macOS Desktop Application"
                      os: macos-10.14 # cmake is pre-installed on macos-10.14+ machines

        steps:
            - name: Checkout Git Repository
              uses: actions/checkout@v2

            # Necessary for Electron to upload packaged applications to AWS S3
            - name: Configure AWS S3 CLI
              uses: aws-actions/configure-aws-credentials@v1
              with:
                  aws-access-key-id: ${{ secrets.AWS_S3_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_S3_SECRET_ACCESS_KEY }}
                  aws-region: us-east-1

            ############################# Windows Configuration Steps START #############################

            - name: Install CUDA on Windows GHA Machine
              if: runner.os == 'Windows'
              env:
                  visual_studio: "Visual Studio 16 2019" # Imported from env in the install_cuda_windows.ps1
                  cuda: "11.0.167" # Imported from env in install_cuda_windows.ps1
              shell: powershell
              working-directory: .github\workflows\helpers\protocol
              run: |
                  .\install_cuda_windows.ps1

                  if ($?) {
                    # Set paths for subsequent steps, using $env:CUDA_PATH
                    echo "Adding CUDA to CUDA_PATH, CUDA_PATH_X_Y and PATH"
                    echo "CUDA_PATH=$env:CUDA_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
                    echo "$env:CUDA_PATH_VX_Y=$env:CUDA_PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
                    echo "$env:CUDA_PATH/bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
                  }

            - name: Verify that NVCC is Installed on GHA Windows Machine
              if: runner.os == 'Windows'
              shell: powershell
              run: |
                  nvcc -V
                  ls $env:CUDA_PATH
                  ls $env:CUDA_PATH\bin
                  ls $env:CUDA_PATH\include

            - name: Install cmake via Chocolatey on Windows GHA Machine
              if: runner.os == 'Windows'
              uses: crazy-max/ghaction-chocolatey@v1
              with:
                  args: install cmake --installargs 'ADD_CMAKE_TO_PATH=System'

            - name: Set up Visual Studio Developer Command Prompt (for nmake)
              if: runner.os == 'Windows'
              uses: ilammy/msvc-dev-cmd@v1

            ############################# Windows Configuration Steps END #############################

            ############################# Unix Configuration Steps START #############################

            - name: Install macOS Codesigning Certificates on macOS GHA Machine
              if: runner.os == 'macOS'
              uses: apple-actions/import-codesign-certs@v1
              with:
                  p12-file-base64: ${{ secrets.MACOS_SIGNING_CERTIFICATE }}
                  p12-password: ${{ secrets.MACOS_SIGNING_CERTIFICATE_PASSWORD }}

            - name: Install Linux Client Protocol Dependencies on Linux Ubuntu GHA Machines
              if: runner.os == 'Linux'
              working-directory: protocol
              run: ./setup-linux-build-environment.sh

            ############################# Unix Configuration Steps END #############################

            - name: Retrieve Desktop App Version from Config Database, Increment Minor Version, and Update Config Database Version
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              shell: bash
              run: |
                  # curl GraphQL API to retrieve version number from config database
                  curl -X POST \
                  -H 'Content-Type: application/json' \
                  -H 'X-Hasura-Admin-Secret: ${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}' \
                  --data "{ \"query\": \"query { desktop_app_version { commit_hash major minor micro } }\" }" \
                  https://config-database.fractal.co/v1/graphql > response.json

                  # parse JSON into major.minor.micro
                  MAJOR=$(cat response.json | jq '.data.desktop_app_version[0].major')
                  MINOR=$(cat response.json | jq '.data.desktop_app_version[0].minor')
                  MICRO=$(cat response.json | jq '.data.desktop_app_version[0].micro')

                  # increment version by 0.0.1
                  NEW_MICRO=$(echo "print( ${MICRO} + 1)" | python)

                  # set new desktop app version
                  NEW_VERSION="${MAJOR}.${MINOR}.${NEW_MICRO}"

                  # remove temporary JSON file and store version in environment variable
                  # store NEW_MICRO in GITHUB_ENV to push to GraphQL API iff job succeeds
                  rm -rf response.json
                  echo "new_micro_version=${NEW_MICRO}" >> $GITHUB_ENV
                  echo "desktop_app_new_version=${NEW_VERSION}" >> $GITHUB_ENV

                  # retrieve git commit hash
                  echo "commit_hash=$(git rev-parse HEAD)" >> $GITHUB_ENV

                  # curl GraphQL API to set new micro version number and git commit hash in config database
                  curl -X POST \
                  -H 'Content-Type: application/json' \
                  -H 'X-Hasura-Admin-Secret: ${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}' \
                  --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {micro: ${{ env.new_micro_version }}, commit_hash: \\\"${{ env.commit_hash }}\\\"}) { id } }\" }" \
                  https://config-database.fractal.co/v1/graphql

            - name: Select AWS S3 Bucket to Publish to Based on GHA Machine OS
              shell: bash
              run: |
                  if [ "$RUNNER_OS" == "Linux" ]; then
                      echo "s3_bucket=fractal-linux-application-release" >> $GITHUB_ENV
                  elif [ "$RUNNER_OS" == "Windows" ]; then
                      echo "s3_bucket=fractal-windows-application-release" >> $GITHUB_ENV
                  else
                      echo "s3_bucket=fractal-mac-application-release" >> $GITHUB_ENV
                  fi

            - name: Publish the Windows Electron Application
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish) && runner.os == 'Windows'
              shell: cmd # Acts as Visual Studio Developer Command Prompt due to ilammy/msvc-dev-cmd@v1
              working-directory: client-applications\desktop
              run: .\publish.bat -branch=master -version=${{ env.desktop_app_new_version }} -bucket=${{ env.s3_bucket }} -publish=true

            - name: Publish the macOS/Linux Ubuntu Electron Applications
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish) && runner.os == 'macOS'
              env:
                  FRACTAL_OSX_SYSROOT: "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk" # Necessary for building on macOS (protocol does NOT support 10.15+ SDKs)
              shell: bash
              working-directory: client-applications/desktop
              run: |
                  # Explicitly retrieve macOS 10.14 SDK
                  wget https://github.com/phracker/MacOSX-SDKs/releases/download/10.15/MacOSX10.14.sdk.tar.xz

                  # Untar it
                  xz -d MacOSX10.14.sdk.tar.xz
                  tar -xf MacOSX10.14.sdk.tar

                  # Move it to the right folder for building the protocol
                  mv MacOSX10.14.sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs

                  # Build the Fractal protocol and package the Electron application
                  ./publish.sh --branch master --version ${{ env.desktop_app_new_version }} --bucket ${{ env.s3_bucket }} --publish true

    # Client Applications: Notify Slack
    # Notify Slack after building and publishing the client applications for all supported OSes.
    # Runs if client-applications-publish-build-s3 succeeds.
    client-applications-notify-slack:
        name: "Client Applications: Notify Slack"
        needs: [client-applications-publish-build-s3]
        if: >
            success() &&
            contains(fromJSON('["all", "client-applications-publish-build-s3"]'), needs.fractal-publish-build-config.outputs.job)
        runs-on: ubuntu-20.04
        steps:
            - name: Notify Slack
              if: contains(fromJSON('["true"]'), needs.fractal-publish-build-config.outputs.publish)
              run: |
                  curl -X POST \
                  --data-urlencode "payload={\"channel\": \"#alerts\", \"username\": \"Fractal Bot\", \"text\": \"Windows and macOS Electron Applications Delpoyed to Production via S3 Upload.\", \"icon_emoji\": \":fractal:\"}" \
                  ${{ secrets.SLACK_HOOKS_ENDPOINT }}
