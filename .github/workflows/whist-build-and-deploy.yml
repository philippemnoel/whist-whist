# workflows/whist-build-and-deploy.yml
#
# Whist: Build & Deploy
# Build and deploy each of the relevant Whist projects for our production, staging and dev environments

name: "Whist: Build & Deploy"

on:
  # On dev, we run a nightly build on weekdays (days of the week 1-5) at 00:01 UTC.
  schedule:
    - cron: "1 0 * * 1,2,3,4,5"
  # On staging & prod, we run a build for each promotion (push to branch).
  push:
    branches:
      - prod
      - staging
    paths-ignore:
      - "README.md"
      - "**/README.md"
      - ".github/workflows/README.md"
  workflow_dispatch:
    inputs:
      target:
        description: |
          The target deployment environment to which the chosen ref
          should be deployed. The target deployment environment
          should be one of "dev", "staging", or "prod". The default
          target deployment environment matches the branch that is
          being deployed.
        required: false
      dry-run:
        description: |
          A boolean indicating whether or not to perform a dry run
          deployment. If this boolean is set, code will be built, but
          not deployed.
        required: true
        # Avoid accidental mistakes by doing dry run deployments by
        # default
        default: true

# This guarantees that if you push many commits to the same PR, only the latest
# commit will get run (others get cancelled)
concurrency:
  group: whist-build-and-deploy-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

jobs:
  # Configure Jobs
  # Detect the branch using regex matching and store as an output to regulate downstream actions.
  # Access branch with `whist-publish-build-config.outputs.branch`.
  whist-publish-build-config:
    name: "Configure Jobs"
    runs-on: ubuntu-20.04
    outputs:
      branch: ${{ steps.set-deploy-environment.outputs.environment }}
      publish: ${{ steps.detect-publish.outputs.publish }}
      scaling_service_url: ${{ steps.set-backend-services-urls.outputs.scaling_service_url }}
      auth0-domain: ${{ steps.set-deploy-environment.outputs.auth0-domain }}
      auth0-client-id: ${{ steps.set-deploy-environment.outputs.auth0-client-id }}
      auth0-client-secret-key: ${{ steps.set-deploy-environment.outputs.auth0-client-secret-key }}
    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Get the whole git history

      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Set deploy environment
        id: set-deploy-environment
        if: ${{ github.event_name == 'push' || github.event_name == 'schedule' || contains(fromJSON('["", "dev", "staging", "prod"]'), github.event.inputs.target) }}
        uses: ./.github/actions/set-environment
        with:
          # Deploy the git ref corresponding to the event that
          # triggered the workflow unless the event that triggered the
          # workflow was a manual workflow_dispatch event. In such a
          # case, the branch specified by the target input should be
          # deployed.
          ref: ${{ github.event.inputs.target || github.ref }}

      - name: Set backend services URL based on Git Branch (prod, staging, dev)
        id: set-backend-services-urls
        run: |
          # Grab the name of the deployment environment from set-deploy-environment
          BRANCH_NAME=${{ steps.set-deploy-environment.outputs.environment }}
          if [ "$BRANCH_NAME" == "prod" ]; then
            SCALING_SERVICE_URL=https://prod-scaling-service.whist.com
          elif [ "$BRANCH_NAME" == "staging" ]; then
            SCALING_SERVICE_URL=https://staging-scaling-service.whist.com
          else
            SCALING_SERVICE_URL=https://dev-scaling-service.whist.com
          fi
          echo "scaling_service_url is set to: $SCALING_SERVICE_URL"
          echo "::set-output name=scaling_service_url::$SCALING_SERVICE_URL"

      - name: Detect Whether to Publish the Job(s) or Not
        id: detect-publish
        run: |
          trap 'echo "::error::Command '\''$BASH_COMMAND'\'' exited with code $?"' ERR
          ref="${{ github.ref }}"
          target="${{ steps.set-deploy-environment.outputs.environment }}"
          case "$ref" in
            *prod|*staging|*dev)
              # Get the short branch name for dev, staging, and
              # prod by stripping away any leading characters. For
              # example, "/refs/heads/dev" becomes "dev".
              branch="${ref##*/}" ;;
            *)
                branch="$ref" ;;
          esac

          # We are only allowed to deploy a branch to its corresponding
          # target deployment environment. In other words, we can only
          # deploy dev to dev, staging to staging, and prod to prod.
          # Feature branches are not deployable.
          deployable="$([ "$branch" != "$target" ] || echo "1")"

          if [[ "${{ github.event_name }}" == "push" || "${{ github.event_name }}" == "schedule" ]]; then
            # If the workflow was triggered by a push or schedule event, the
            # dry-run input is not available. We can assert that the
            # push event was triggered on either dev, staging, or
            # prod, and then set the dry run flag to false.
            [[ "$branch" =~ dev|staging|prod ]]
            dry_run="false"
          else
            dry_run="${{ github.event.inputs.dry-run }}"

            # If we're trying to perform a real deployment, but the
            # current configuration is not deployable, abort.
            test "$deployable" -o "$dry_run" != "false"
          fi

          # Publish the job outputs iff this is not a dry run and
          # the git branch that we're deploying matches the target
          # deployment environment.
          publish="$([ "$deployable" -a "$dry_run" = "false" ] && echo "true" || echo "false")"

          echo "Publish is set to: $publish"
          echo "::set-output name=publish::$publish"

      - name: Notify Slack on Job Error
        if: failure()
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ steps.set-deploy-environment.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ steps.set-deploy-environment.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          BODY = "@releases :rotating_light: Deployment failed: could not generate configs for deployment in `whist-publish-build-config` job, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

  #######################################################################################
  #######################################################################################

  # Auth0 Rules: Build & Deploy Auth0 Rules to Auth0 Tenant
  # Build and deploy the Auth0 rules to the Whist Auth0 Tenant platform, with
  # which our frontend interfaces with for authenticating users through Auth0
  # Runs if config succeeds and branch is in ["prod", "staging", "dev"]
  auth0-deploy-rules:
    name: "Deploy Auth0 Rules"
    runs-on: ubuntu-20.04
    concurrency: auth0-deploy-rules-${{ github.ref }}
    needs: [whist-publish-build-config]

    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3

      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Set up NodeJS Environment
        uses: actions/setup-node@v3.4.1
        with:
          node-version: "16"

      - name: Install Development Dependencies
        working-directory: backend/auth0
        run: yarn install

      - name: Deploy Changes to the Auth0 Tenant
        working-directory: backend/auth0
        env:
          AUTH0_CLIENT_SECRET: ${{ secrets[format('AUTH0_GHA_CLIENT_SECRET_{0}', needs.whist-publish-build-config.outputs.branch)] }}
          GOOGLE_OAUTH_SECRET: ${{ secrets.GOOGLE_OAUTH_SECRET }}
          APPLE_OAUTH_SECRET: ${{ secrets.APPLE_OAUTH_SECRET }}
        run: yarn deploy:${{ needs.whist-publish-build-config.outputs.branch }}

      - name: Notify Slack on Job Success
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          TITLE = ":auth0: Auth0 Rules Deployed :auth0:"
          BODY = f"Auth0 Rules deployed to Auth0 Tenant on branch: `${{ needs.whist-publish-build-config.outputs.branch }}` (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)

      - name: Notify Slack on Job Error
        if: failure()
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          BODY = "@releases :rotating_light: Deployment failed: could not deploy Auth0 Rules in `auth0-deploy-rules` job, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

  #######################################################################################
  #######################################################################################

  # Terraform: Deploy infrastructure
  # 1 - Setup Terraform and plan
  # 2 - Run Terraform apply to deploy infrastructure.
  terraform-deploy:
    name: Deploy Terraform
    runs-on: ubuntu-20.04
    needs: [whist-publish-build-config]
    env:
      # Set AWS credentials for Terraform
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}

    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3

      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Setup Terraform CLI
        uses: hashicorp/setup-terraform@v2

      - name: Initialize Terraform
        working-directory: backend/infrastructure
        run: cd "$GITHUB_REF_NAME" && terraform init -input=false

      - name: Terraform Plan
        working-directory: backend/infrastructure
        run: cd "$GITHUB_REF_NAME" && terraform plan -input=false -out=tfplan

      - name: Terraform Apply
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        working-directory: backend/infrastructure
        run: cd "$GITHUB_REF_NAME" && terraform apply -input=false -auto-approve tfplan

      - name: Notify Slack on Successful Terraform Apply
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          TITLE = ":earth_americas: Infrastructure successfully deployed :earth_americas:"
          BODY = f"Infrastructure deployed with Terraform: `${{ needs.whist-publish-build-config.outputs.branch }}` (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)

      - name: Notify Slack on Job Error
        if: failure()
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          SCALING_SERVICE_URL = "${{ needs.whist-publish-build-config.outputs.scaling_service_url }}"
          BODY = f"@releases :rotating_light: Infrastructure failed to deploy, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

  #######################################################################################
  #######################################################################################

  # Mandelboxes: Publish to GHCR
  # This job builds and publishes the mandelboxes to GHCR so that they can be pulled from our instances.
  # We invoke a separate workflow file to keep things nicely factored out.
  #
  # Runs if config succeeds and branch is in ["dev", "staging", "prod"]
  mandelboxes-publish-ghcr:
    name: "Mandelboxes: Publish to GHCR"
    needs: [whist-publish-build-config]
    concurrency: mandelboxes-publish-ghcr-${{ github.ref }}
    uses: ./.github/workflows/mandelboxes-publish-ghcr.yml
    with:
      branch: ${{ needs.whist-publish-build-config.outputs.branch }}
      publish: ${{ needs.whist-publish-build-config.outputs.publish == 'true' }}
    secrets:
      SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
      GHA_USERNAME: ${{ secrets.GHA_USERNAME }}
      GHA_PERSONAL_ACCESS_TOKEN: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
      AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
      AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}
      SLACK_HOOKS_ENDPOINT_DEV: ${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}
      SLACK_HOOKS_ENDPOINT_STAGING: ${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}
      SLACK_HOOKS_ENDPOINT_PROD: ${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}

  #######################################################################################
  #######################################################################################

  # AMIs: Build & Publish Whist AMIs
  # This job builds and publishes the Whist Linux AMI, containing the pre-built Whist Host service,
  # to all supported AWS EC2 regions.
  #
  # Runs if config succeeds, terraform has deployed, and branch is in ["dev", "staging", "prod"]
  amis-publish-aws:
    name: "AMIs: Publish to AWS"
    runs-on: ubuntu-20.04
    concurrency: amis-publish-aws-${{ github.ref }}
    needs: [whist-publish-build-config, terraform-deploy]
    outputs:
      region_to_ami_map: ${{ steps.build-new-amis.outputs.region_to_ami_map }}

    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3

      - name: Configure AWS CLI # To get and install GRID driver
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set up Python Environment
        uses: actions/setup-python@v4.1.0
        with:
          python-version: "3.10.4"

      - name: Setup Python-based notifications # slack notifications need to be set up before steps that can lead to errors
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh "true"

      ##########################################################################################
      ########################### Stage 1 - Build Backend Services #############################

      - name: Set up Go Environment
        uses: actions/setup-go@v3.2.1
        with:
          go-version: "1.18"

      - name: Authenticate Go commands with GitHub
        env:
          GH_USERNAME: ${{ secrets.GHA_USERNAME }}
          GH_PAT: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
        run: git config --global url.https://$GH_USERNAME:$GH_PAT@github.com/.insteadOf https://github.com/

      - name: Build Backend Services
        working-directory: backend/services
        env:
          HEROKU_USER: developers@whist.com
          HEROKU_APIKEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
        run: make build

      ##########################################################################################
      ####################### Stage 2 - Build & Publish AMIs to AWS EC2 ########################

      - name: Set Host Service APP_ENV based on Git Branch (File gets read by host-service.service)
        working-directory: host-setup
        run: |
          BRANCH_NAME="${{ needs.whist-publish-build-config.outputs.branch }}"

          if [ "$BRANCH_NAME" == "prod" ]; then
            echo 'APP_ENV=PROD' > app_env.env
            echo 'LOGZIO_SHIPPING_TOKEN=${{ secrets.LOGZ_SHIPPING_TOKEN_PROD }}' >> app_env.env
          elif [ "$BRANCH_NAME" == "staging" ]; then
            echo 'APP_ENV=STAGING' > app_env.env
            echo 'LOGZIO_SHIPPING_TOKEN=${{ secrets.LOGZ_SHIPPING_TOKEN_STAGING }}' >> app_env.env
          else
            echo 'APP_ENV=DEV' > app_env.env
            echo 'LOGZIO_SHIPPING_TOKEN=${{ secrets.LOGZ_SHIPPING_TOKEN_DEV }}' >> app_env.env
          fi
          echo 'SENTRY_DSN=https://774bb2996acb4696944e1c847c41773c@o400459.ingest.sentry.io/5461239' >> app_env.env
          echo 'USE_PROD_LOGGING=true' >> app_env.env
          cat app_env.env

      - name: Set Github account, PAT and commit hash (File gets read by userdata script)
        working-directory: host-setup
        run: |
          echo 'GH_USERNAME=${{ secrets.GHA_USERNAME }}' >> app_env.env
          echo 'GH_PAT=${{ secrets.GHCR_PACKAGES_READ_ONLY_PAT }}' >> app_env.env
          echo 'GIT_BRANCH=${{ needs.whist-publish-build-config.outputs.branch }}' >> app_env.env
          echo 'GIT_HASH=${{ github.sha }}' >> app_env.env

      # This spins up an AWS EC2 instance to create the AMI, and then deletes it
      # It *could* fail if we are maxed-out in number AWS vCPUs allowed in aws_new_ami_source_region
      - name: Generate Packer Configuration, Create New AMI, Update Region, and Update Appropriate Database
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        id: build-new-amis
        working-directory: host-setup
        shell: python3 {0}
        run: |
          import os, json, datetime, subprocess

          # Get the current date and time
          date_str = datetime.datetime.utcnow().strftime("%Y-%m-%d-%H-%M-%S")

          # Generate the Packer configuration variables
          data = {}
          data["git_branch"] = "${{ needs.whist-publish-build-config.outputs.branch }}"
          data["git_hash"] = "${{ github.sha }}"
          data["access_key"] = "${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}"
          data["secret_key"] = "${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}"
          data["ami_name"] = f"whist-ami-${{ needs.whist-publish-build-config.outputs.branch }}-${{ github.sha }}-{date_str}"

          # List all AWS regions we support
          supported_aws_regions = [
            "us-east-1",
            "us-east-2",
            "us-west-1",
            "us-west-2",
            "ca-central-1",
            "sa-east-1",
            "eu-north-1",
            "eu-south-1",
            "eu-west-1",
            "eu-west-2",
            "eu-west-3",
            "eu-central-1",
            "me-south-1",
            "ap-east-1",
            "ap-south-1",
            "ap-southeast-1",
            "ap-southeast-2",
            "ap-southeast-3",
            "ap-northeast-1",
            "ap-northeast-2",
            "ap-northeast-3",
            "af-south-1",
          ]

          # Set Logz.io shipping token and regions to which to deploy the new AMI based on the environment.
          # For internal environments (dev, staging), we only clone our new AMI to us-east-1 and us-west-1, to save on
          # costs since we don't have/need test users in other regions.
          if data["git_branch"] == "prod":
            data["mandelbox_logz_shipping_token"] = "${{ secrets.LOGZ_SHIPPING_TOKEN_PROD }}"
            data["destination_regions"] = supported_aws_regions
          elif data["git_branch"] == "staging":
            data["mandelbox_logz_shipping_token"] = "${{ secrets.LOGZ_SHIPPING_TOKEN_STAGING }}"
            data["destination_regions"] = ["us-east-1"]
          elif data["git_branch"] == "dev":
            data["mandelbox_logz_shipping_token"] = "${{ secrets.LOGZ_SHIPPING_TOKEN_DEV }}"
            data["destination_regions"] = ["us-east-1"]
          else:
            raise Exception(f"Invalid environment/git branch: {data['git_branch']}")

          # Packer isn't able to loop over AWS Regions by itself. To work around this, we need to loop over all AWS regions
          # regions ourselves, until one of them has capacity (only returning an error if there is no capacity in any of the
          # regions). We could eventually also manually loop over availability zones, but this is probably not necessary as
          # Packer will attempt to autoassign the most optimal availibity zone for the Packer instance.
          for aws_region in supported_aws_regions:
            data["initial_region"] = aws_region

            # Write the generated Packer variables to a file
            fp = open("packer_vars.json", "w")
            json.dump(data, fp)
            fp.close()

            # Display file content, for debugging purposes
            subprocess.run("cat packer_vars.json && echo '\n\n'", shell=True)

            # Validate the Packer variables file for syntax errors
            subprocess.run("packer validate -var-file=packer_vars.json ami_config.pkr.hcl && echo '\n\n'", shell=True)

            # Generate AMIs via Packer
            # Stdout will be shared with the subprocess so that we can see what is happening
            # If you need to debug Packer, add `PACKER_LOG=1` before `packer build ...` in the subprocess.run command
            subprocess.run("packer build -var-file=packer_vars.json ami_config.pkr.hcl", shell=True)

            # If Packer succeeds, it will create `manifest.json`, which is our cue to stop trying other regions
            if os.path.exists("manifest.json"):
              print("Packer succeeded, exiting AWS Regions zones loop...")
              break

          # Assert that `manifest.json` exists after looping over all AWS Regions to fail the workflow in the event that
          # we couldn't get capacity in any of the AWS regions
          assert os.path.exists("manifest.json")

          # Save Packer output to a JSON, to use for creating new instances with the newly created AMI
          fp = open("manifest.json", "r")
          data = json.load(fp)
          fp.close()
          print("Printing Packer output: " + str(data))

          # Extract relevant data for creating new instances with this AMI
          new_ami_ids = data["builds"][0]["artifact_id"]
          region_ami_pairs = new_ami_ids.split(",")

          REGION_TO_AMI_MAP = dict()
          for region_ami_pair in region_ami_pairs:
            region_name, ami = region_ami_pair.split(":")
            REGION_TO_AMI_MAP[region_name] = ami

          # export REGION_TO_AMI_MAP
          # the .replace(...) makes all occurrences of a double quote " be prefixed by a \
          # it is best to explain via example:
          # >>> data = {'key': "val'ue"} # tricky example because we have single and double quotes
          # >>> print(json.dumps(data).replace('"', '\\"'))
          # {\"key\": \"val'ue\"} # this is saved as an output
          # LATER, when we need to use this output
          # >>> data = json.loads("{{ OUTPUT }}") # OUTPUT expands to {\"key\": \"val'ue\"}
          # >>> print(data)
          # {'key': "val'ue"}
          # if I did not add the \, then the json library would get confused by trying to read this:
          # >>> json.loads("{"key": "val'ue"}") # fails, we need the \ prefix
          region_to_ami_map_str = json.dumps(REGION_TO_AMI_MAP).replace('"', '\\"')

          print(f"Region to AMI map is set to {region_to_ami_map_str}")
          print(f"::set-output name=region_to_ami_map::{region_to_ami_map_str}")

      ##########################################################################################
      ############################# Stage 3 - Slack Notifications ##############################

      # Notify Slack after building and deploying the Whist AMI to all supported AWS regions.
      - name: Notify Slack on Job Successs
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          TITLE = ":package: AMIs Deployed :package:"
          BODY = "AMIs deployed to all supported AWS regions on branch: `${{ needs.whist-publish-build-config.outputs.branch }}` (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)

      - name: Notify Slack on Job Error
        if: failure()
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          BODY = "@releases :rotating_light: Deployment failed: could not deploy AMIs in the `amis-publish-aws` job, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

  # Whist Browser: Retrieve Version Number
  # Retrieve the current Whist version number from our configuration database, through Hasura
  # This is the first step in the Whist Browser deployment jobs
  whist-browser-retrieve-version-number:
    name: "Whist Browser: Retrieve Current Version Number from Config Database"
    runs-on: ubuntu-20.04
    concurrency: whist-browser-retrieve-version-number-${{ github.ref }}
    needs:
      [
        whist-publish-build-config,
        scaling-service-deploy,
        auth0-deploy-rules,
        terraform-deploy,
      ]
    outputs:
      release_version: ${{ steps.generate-release-version.outputs.release_version }}
      new_micro_version: ${{ steps.generate-release-version.outputs.new_micro_version }}
      new_staging_rc_version: ${{ steps.generate-release-version.outputs.new_staging_rc_version }}
      new_dev_rc_version: ${{ steps.generate-release-version.outputs.new_dev_rc_version }}

    # Only run whist-browser deployment if none of the previous steps failed
    if: |
      always() &&
      (needs.scaling-service-deploy.result == 'success') &&
      (needs.auth0-deploy-rules.result == 'success') &&
      (needs.mandelboxes-publish-ghcr.result == 'success') &&
      (needs.amis-publish-aws.result == 'success')

    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3

      - name: Retrieve Whist Desktop Browser Version from Config Database
        id: generate-release-version
        shell: bash --noprofile --norc -eo pipefail {0}
        run: |
          BRANCH_NAME="${{ needs.whist-publish-build-config.outputs.branch }}"
          ACCESS_KEY='${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}'

          # curl GraphQL API to retrieve version number from config database
          curl -X POST \
          -H "Content-Type: application/json" \
          -H "X-Hasura-Admin-Secret: $ACCESS_KEY" \
          --data "{ \"query\": \"query { desktop_app_version { major minor micro dev_rc staging_rc } }\" }" \
          https://config-database.whist.com/v1/graphql > response.json

          # Check if we actually got back valid json. If not, we should
          # throw a human-readable error because the config DB might be
          # down.
          if cat response.json | jq -e . > /dev/null 2>&1; then
            echo "Got some valid JSON from the config DB:"
            cat response.json
            echo
            echo "Continuing..."
          else
            echo "Failed to parse the JSON from the config DB. Is it up?" && false
          fi

          # parse JSON into major.minor.micro-rc
          MAJOR=$(cat response.json | jq '.data.desktop_app_version[0].major')
          MINOR=$(cat response.json | jq '.data.desktop_app_version[0].minor')
          MICRO=$(cat response.json | jq '.data.desktop_app_version[0].micro')
          DEV_RC=$(cat response.json | jq '.data.desktop_app_version[0].dev_rc')
          STAGING_RC=$(cat response.json | jq '.data.desktop_app_version[0].staging_rc')

          # remove temporary JSON file
          rm response.json

          echo "Current prod version: $MAJOR.$MINOR.$MICRO"
          echo "Current staging version: $MAJOR.$MINOR.$MICRO-staging-rc.$STAGING_RC"
          echo "Current dev version: $MAJOR.$MINOR.$MICRO-dev-rc.$DEV_RC"

          # if dev or staging, increment RC by 1, else increment micro by 1 and set RC to 0
          if [[ "$BRANCH_NAME" == "prod" ]]; then
            echo 'Using prod configuration...'

            # increment version by 0.0.1
            NEW_MICRO=$(echo "print( ${MICRO} + 1)" | python)

            # set new Whist Desktop Browser version
            NEW_VERSION="${MAJOR}.${MINOR}.${NEW_MICRO}"

            # store NEW_MICRO in GITHUB_ENV to push to GraphQL API, and reset STAGING_RC and DEV_RC to 0
            echo "::set-output name=new_micro_version::${NEW_MICRO}"
            echo "::set-output name=new_staging_rc_version::0"
            echo "::set-output name=new_dev_rc_version::0"
          elif [[ "$BRANCH_NAME" == "staging" ]]; then
            echo 'Using staging configuration...'

            # increment version by staging-rc.1
            NEW_STAGING_RC=$(echo "print( ${STAGING_RC} + 1)" | python)

            # set temporary variable for upcoming micro version which is 1 ahead of current, since
            # staging/dev are release candiates (rc) for the next version
            # we don't push that micro version to GraphQL in staging/dev, only on prod when it becomes current
            UPCOMING_MICRO=$(echo "print( ${MICRO} + 1)" | python)

            # set new Whist Desktop Browser version
            NEW_VERSION="${MAJOR}.${MINOR}.${UPCOMING_MICRO}-staging-rc.${NEW_STAGING_RC}"

            # store NEW_STAGING_RC in GITHUB_ENV to push to GraphQL API
            echo "::set-output name=new_staging_rc_version::${NEW_STAGING_RC}"
          elif [[ "$BRANCH_NAME" == "dev" ]]; then
            echo 'Using dev configuration...'

            # increment version by dev-rc.1
            NEW_DEV_RC=$(echo "print( ${DEV_RC} + 1)" | python)
            
            # set temporary variable for upcoming micro version which is 1 ahead of current, since
            # staging/dev are release candiates (rc) for the next version
            # we don't push that micro version to GraphQL in staging/dev, only on prod when it becomes current
            UPCOMING_MICRO=$(echo "print( ${MICRO} + 1)" | python)

            # set new Whist Desktop Browser version [-x64/-arm64] gets appended depending on the OS architecture it is built on
            NEW_VERSION="${MAJOR}.${MINOR}.${UPCOMING_MICRO}-dev-rc.${NEW_DEV_RC}"

            # store NEW_DEV_RC in GITHUB_ENV to push to GraphQL API
            echo "::set-output name=new_dev_rc_version::${NEW_DEV_RC}"
          else
            echo 'Error: Invalid branch' && false
          fi

          # store new Whist Desktop Browser version as GitHub step output to substitute in GitHub Release tag creation
          echo "New $BRANCH_NAME version: ${NEW_VERSION}"
          echo "::set-output name=release_version::${NEW_VERSION}"

  #######################################################################################
  #######################################################################################

  # Whist Browser: Build and Publish to AWS S3
  # Build the Whist Browser for all supported OSes
  whist-browser-publish-build-s3:
    name: "Whist Browser: Build & Deploy Whist Browser (${{ matrix.config.display_os }} - ${{ matrix.config.target_arch }})"
    runs-on: ${{ matrix.config.runner }}
    concurrency: whist-browser-publish-build-s3-${{ matrix.config.target_arch }}-${{ matrix.config.target_os }}-${{ github.ref }}
    needs:
      [
        whist-publish-build-config,
        whist-browser-retrieve-version-number,
        terraform-deploy,
      ]

    # Only run whist-browser deployment if none of the previous steps failed
    if: always() && (needs.whist-browser-retrieve-version-number.result == 'success')

    strategy:
      matrix:
        config:
          # This builds the client-side macOS Whist Browser
          - target_arch: "x64"
            display_os: "macOS"
            target_os: "macos"
            runner: [self-hosted, macOS, ARM64]
          # This builds the client-side macOS Whist Browser
          - target_arch: "arm64"
            display_os: "macOS"
            target_os: "macos"
            runner: [self-hosted, macOS, ARM64]
          # This builds the server-side Linux Whist Browser (running in our mandelboxes)
          - target_arch: "x64"
            display_os: "Linux Ubuntu"
            target_os: "linux"
            runner: [self-hosted, Linux, x64]

    env:
      binary-tar-name: whist-browser-${{ matrix.config.target_os }}-${{ matrix.config.target_arch }}-${{ needs.whist-publish-build-config.outputs.branch }}.tar.gz
      s3-bucket-uri: s3://whist-browser-${{ matrix.config.target_os }}-${{ matrix.config.target_arch }}-${{ needs.whist-publish-build-config.outputs.branch }}
      s3-bucket-region: us-east-1
      build_type: "Release" # Change this to Debug or Component if you're looking to generate a release with more symbols

    steps:
      ############################## Common Configuration Steps START #############################

      # This helps fix an issue with GitHub Actions not finding the right keychain on macOS self-hosted runners
      - name: Configure keychain
        if: runner.os == 'macOS'
        run: git config --global credential.helper osxkeychain

      - name: Authenticate with GitHub (for pulling the required repositories automatically from the build scripts)
        env:
          GH_USERNAME: ${{ secrets.GHA_USERNAME }}
          GH_PAT: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
        run: git config --global url.https://$GH_USERNAME:$GH_PAT@github.com/.insteadOf https://github.com/

      - name: Manually Git Clone `brave-browser`
        run: |
          # Since this is a self-hosted runner, we check if the `brave-browser` repo exists locally,
          # and if so we pull the latest changes. If it doesn't exist, we clone it.
          if [ -d "brave-browser" ]; then
            echo "Entering brave-browser..."
            cd brave-browser

            # Log the branch, should always be `main`, but we checkout just to be sure
            git branch
            git checkout main
            git pull
            git branch

            # We then do the same for the `brave-core` repo within the `brave-browser` repo.
            if [ -d "src/brave" ]; then
              echo "Entering src/brave (brave-core)..."
              cd src/brave

              # Log the branch, should always be `dev`, `staging`, or `prod`, but we checkout just to be sure
              git branch
              git checkout ${{ needs.whist-publish-build-config.outputs.branch }}
              git pull
              git branch

              # We then do the same for the `whist` repo within the `brave-core` repo.
              if [ -d "whist" ]; then
                echo "Entering whist..."
                cd whist

                # Log the branch, should always be `dev`, `staging`, or `prod`, but we checkout just to be sure
                git branch
                git checkout ${{ needs.whist-publish-build-config.outputs.branch }}
                git pull
                git branch
              fi
            fi
          else
            git clone "https://${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}@github.com/whisthq/brave-browser.git" brave-browser
          fi

      - name: Configure AWS S3 CLI
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_GITHUB_ACTIONS_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_GITHUB_ACTIONS_USER_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.s3-bucket-region }}

      #############################################################################################
      ############################# Windows Configuration Steps START #############################

      - name: Install cmake via Chocolatey on Windows GHA Machine
        if: runner.os == 'Windows'
        uses: crazy-max/ghaction-chocolatey@v2
        with:
          args: install cmake --pre --no-progress --installargs 'ADD_CMAKE_TO_PATH=System'

      - name: Set up Visual Studio Developer Command Prompt (for nmake)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1

      #############################################################################################
      ############################### macOS Configuration Steps START #############################

      # Since we're using a self-hosted runner, we need to comment this out once it has run once
      # because the keychain will then exist and trying to reinstall it will fail. If you are
      # running this workflow on a new runner, simply uncomment this step for the first run.
      # - name: Install macOS Codesigning Certificates on macOS GHA Machine
      #   if: runner.os == 'macOS'
      #   uses: apple-actions/import-codesign-certs@v1
      #   with:
      #     p12-file-base64: ${{ secrets.MACOS_SIGNING_P12_CERTIFICATES_BASE64_ENCODED }}
      #     p12-password: ${{ secrets.MACOS_SIGNING_P12_CERTIFICATES_BASE64_ENCODED_PASSWORD }}

      # This step follows the specs in https://github.com/electron/electron-notarize#notes-on-jwt-authentication
      - name: Install macOS Notarization API Key
        if: runner.os == 'macOS'
        run: |
          mkdir -p ~/private_keys
          aws s3 cp s3://whist-dev-secrets/AuthKey_${{ secrets.APPLE_API_KEY_ID }}.p8 ~/private_keys

      #############################################################################################
      ############################### Linux Configuration Steps START #############################

      # The Linux runner for building Chromium Whist needs to first be configured manually with some other packages. I am
      # writing them here for reference, in case we need to create a new self-hosted runner
      #    sudo apt-get install build-essential python-setuptools python3-distutils pkg-config gperf git gh libxdamage1 libgbm1 libatk1.0-0 awscli libdbus-1-dev
      #    sudo apt-get install libasound2-dev libcurl4-openssl-dev libatk-bridge2.0-0 libxkbcommon-x11-0 libpango-1.0-0 nvidia-cuda-toolkit awscli
      #    sudo snap install cmake --classic
      #
      # Also, the AWS CLI needs to be configured with `aws configure`

      # See: https://github.com/brave/brave-browser/wiki/Linux-Development-Environment
      - name: Install Linux Ubuntu Brave Browser Dependencies
        if: runner.os == 'Linux'
        working-directory: brave-browser
        run: ./src/build/install-build-deps.sh --no-prompt --no-nacl --no-chromeos-fonts --no-arm

      #############################################################################################
      ##################################### Build Steps START #####################################

      # Building Brave/Chromium requires specific Node & npm versions, and Xcode. For full
      # details, see: https://github.com/whisthq/brave-browser#readme
      # These are fine to set globally even if the self-hosted runner is used by a Whist engineer
      # since the Node, NPM, and Xcode versions should match for development and deploys.
      - name: Log NodeJS, NPM and Xcode (on macOS only) Versions
        run: |
          # Necessary to use nvm from bash on macOS (needs nvm to be installed already)
          source ~/.nvm/nvm.sh

          echo "Force NodeJS version 16 and NPM version 8.5.5..."
          nvm install 16
          nvm use 16
          npm install -g npm@8.5.5

          echo ""
          echo "Verifying NodeJS & NPM versions (Need 16.x and 8.5.5)..."
          echo -n "NodeJS version: " && node --version
          echo -n "NPM version: " && npm --version

          if [[ "${{ runner.os }}" == "macOS" ]]; then
            echo ""
            echo "Verifying that Xcode is installed and up-to-date (Need 13.x)..."
            xcodebuild -version
          fi

      - name: Initialize the Build Environment
        working-directory: brave-browser
        run: |
          # nvm doesn't scope well across GitHub Actions steps on Linux, so we forcefully make sure that it is using
          # the proper versions of NodeJS & NPM
          source ~/.nvm/nvm.sh
          nvm use 16 && echo -n "NPM version: " && npm --version

          # Install dependencies
          npm install

      - name: Configure Build Type
        working-directory: brave-browser
        run: |
          # Set the whisthq/brave-core and whisthq/whist branches to `dev`, `staging` or `prod` to be in-sync
          export npm_config_projects_brave_core_branch=${{ needs.whist-publish-build-config.outputs.branch }}
          export npm_config_projects_whist_branch=${{ needs.whist-publish-build-config.outputs.branch }}

          # We build a Release build for every Whist environment, but target the analoguous Brave release channel
          # See brave-core/build/config.gni for more info
          # - dev: "nightly"
          # - staging: "beta"
          # - prod: "" (defaults to "release")
          if [[ "${{ needs.whist-publish-build-config.outputs.branch }}" == "prod" ]]; then
            # Production build, set official build as true and build Chromium as Release
            export npm_config_is_official_build=true
            echo "release_channel=''" >> $GITHUB_ENV
          elif [[ "${{ needs.whist-publish-build-config.outputs.branch }}" == "staging" ]]; then
            # Staging build, set official build as false and build Chromium as Release
            export npm_config_is_official_build=false
            echo "release_channel=beta" >> $GITHUB_ENV
          else
            # Dev build, set official build as false and build Chromium as Debug
            export npm_config_is_official_build=false
            echo "release_channel=nightly" >> $GITHUB_ENV
          fi

          # Set the proper package name for the build
          #
          # TODO: Sign the macOS package and update the file path accordingly
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            echo "executable_name=unsigned/Whist Browser.dmg" >> $GITHUB_ENV
          elif [[ "${{ runner.os }}" == "Linux" ]]; then
            # TODO: We need to rename this to something like `whist-browser`
            echo "executable_name=brave" >> $GITHUB_ENV
          else
            echo "Unsupported OS for setting Whist Browser executable name!"
            exit 1
          fi

      # We need to configure build parameters, to build for the proper architecture and with
      # the relevant flags for the selected build type. Note that we cannot/don't want to use
      # a lot of Brave-specific services, which are either omitted or filled-in with a placeholder.
      #
      # List of potential flags can be found here:
      # https://github.com/whisthq/brave-core/blob/main/build/commands/lib/config.js#L77
      # https://github.com/brave/brave-core/blob/master/build/commands/scripts/commands.js#L71
      #
      # Note that we must use environment variables starting with npm_config_ intead of directly setting
      # global `npm config set ...`, so to not interfere with developers working on the self-hosted runner
      - name: Configure Build Parameters
        working-directory: brave-browser
        run: |
          # Set architecture and version
          export npm_config_target_arch=${{ matrix.config.target_arch }}
          export npm_config_target_os=${{ matrix.config.target_os }}
          export npm_config_version=${{ env.release_version }}

          # Configure Whist integration with Google APIs
          # This key is from the `Whist Chromium Browser` GCP project, under the `whist.com` GCP organization
          export npm_config_brave_google_api_key=${{ secrets.WHIST_CHROMIUM_BROWSER_GCP_PROJECT_GOOGLE_API_KEY }}
          export npm_config_safebrowsing_api_endpoint=https://safebrowsing.googleapis.com/v4/...?key=${{ secrets.WHIST_CHROMIUM_BROWSER_GCP_PROJECT_GOOGLE_API_KEY }}

          # Configure Google OAuth integration with Whist
          export npm_config_google_default_client_id=${{ secrets.GOOGLE_OAUTH_CLIENT_ID }}
          export npm_config_google_default_client_secret=${{ secrets.GOOGLE_OAUTH_SECRET }}

          # TODO: Configure a variations server for Whist to enable A/B testing
          # export npm_config_brave_variations_server_url=https://

          # TODO: Configure a web compatibility endpoint to enable legacy web compatibility
          # export npm_config_webcompat_report_api_endpoint=https://webcompat.brave.com/1/webcompat

          # TODO: Configure Apple Notarization
          # Potential secrets to use: 
          #    APPLE_API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          #    APPLE_API_KEY_ISSUER_ID: ${{ secrets.APPLE_API_KEY_ISSUER_ID }}
          # export npm_config_notary_user=
          # export npm_config_notary_password=
          # export npm_config_mac_signing_keychain=login
          # export npm_config_mac_signing_identifier=
          # export npm_config_mac_installer_signing_identifier=

          # We don't update Whist extensions separately from the Chromium browser, so we don't need to
          # configure any update servers.
          export npm_config_updater_dev_endpoint=https://
          export npm_config_updater_prod_endpoint=https://

          # This is related to generic Brave services, which we don't use in the product,
          # so we provide dummy values
          export npm_config_brave_services_key=fake
          export npm_config_brave_stats_updater_url=https://

          # This is related to Brave Sync, which we don't use in the product,
          # so we provide a dummy value
          export npm_config_brave_sync_endpoint=https://

          # These are all related to Brave Rewards/Wallet, which we don't use in the product,
          # so we provide dummy values
          export npm_config_uphold_client_id=fake
          export npm_config_uphold_client_secret=fake
          export npm_config_gemini_wallet_client_id=fake
          export npm_config_gemini_wallet_client_secret=fake
          export npm_config_gemini_api_url=https://
          export npm_config_gemini_oauth_url=https://
          export npm_config_rewards_grant_dev_endpoint=https://
          export npm_config_rewards_grant_staging_endpoint=https://
          export npm_config_rewards_grant_prod_endpoint=https://

      - name: Fetch Chromium Source & Dependencies
        working-directory: brave-browser
        run: |
          # nvm doesn't scope well across GitHub Actions steps on Linux, so we forcefully make sure that it is using
          # the proper versions of NodeJS & NPM
          source ~/.nvm/nvm.sh
          nvm use 16 && echo -n "NPM version: " && npm --version

          # Download and prepare Chromium/Brave for building
          npm run init

      - name: Build Whist Browser
        working-directory: brave-browser
        run: |
          # nvm doesn't scope well across GitHub Actions steps on Linux, so we forcefully make sure that it is using
          # the proper versions of NodeJS & NPM
          source ~/.nvm/nvm.sh
          nvm use 16 && echo -n "NPM version: " && npm --version

          # Set the environment variables for the Whist Extension
          # Note that these values are public, so it's fine to hardcode them here (rather than using GitHub Secrets)
          #
          # TODO: Create a per-environment Amplitude project, and have a different key for each environment
          if [[ "${{ needs.whist-publish-build-config.outputs.branch }}" == "prod" ]]; then
            export WHIST_AUTH0_CLIENT_ID=Ulk5B2RfB7mM8BVjA3JtkrZT7HhWIBLD
            export WHIST_AUTH0_DOMAIN_URL=auth.whist.com
            export WHIST_AUTH0_REDIRECT_URL=https://auth.whist.com/callback
            export WHIST_SCALING_SERVICE_URL=https://prod-scaling-service.whist.com
            export WHIST_AMPLITUDE_KEY=${{ secrets.WHIST_AMPLITUDE_KEY }}
          elif [[ "${{ needs.whist-publish-build-config.outputs.branch }}" == "staging" ]]; then
            export WHIST_AUTH0_CLIENT_ID=WXO2cphPECuDc7DkDQeuQzYUtCR3ehjz
            export WHIST_AUTH0_DOMAIN_URL=fractal-staging.us.auth0.com
            export WHIST_AUTH0_REDIRECT_URL=https://fractal-staging.us.auth0.com/callback
            export WHIST_SCALING_SERVICE_URL=https://staging-scaling-service.whist.com
            export WHIST_AMPLITUDE_KEY=${{ secrets.WHIST_AMPLITUDE_KEY }}
          else
            export WHIST_AUTH0_CLIENT_ID=DIy0YQZrMeMO97Thjr13EpkGCy792XWx
            export WHIST_AUTH0_DOMAIN_URL=fractal-dev.us.auth0.com
            export WHIST_AUTH0_REDIRECT_URL=https://fractal-dev.us.auth0.com/callback
            export WHIST_SCALING_SERVICE_URL=https://dev-scaling-service.whist.com
            export WHIST_AMPLITUDE_KEY=${{ secrets.WHIST_AMPLITUDE_KEY }}
          fi
          cd src/brave/whist
          export WHIST_COMMIT_SHA=$(git rev-parse ${{ needs.whist-publish-build-config.outputs.branch }})
          cd ../../..

          # Build the browser
          npm run build ${{ env.build_type }} -- --channel=${{ env.release_channel }}

      - name: Package Whist Browser
        working-directory: brave-browser
        run: |
          # nvm doesn't scope well across GitHub Actions steps on Linux, so we forcefully make sure that it is using
          # the proper versions of NodeJS & NPM
          source ~/.nvm/nvm.sh
          nvm use 16 && echo -n "NPM version: " && npm --version

          # Package the browser into an installer
          npm run create_dist -- --channel=${{ env.release_channel }}

      # Each final build of WhistClient has an internal build ID and debug ID. Sentry will use these
      # IDs to match the debug symbols with the build that crashed to build the backtrace
      # Note: Sentry makes use of sudo. To make it work on a self-hosted macOS runner, follow:
      # https://apple.stackexchange.com/questions/257813/enable-sudo-without-a-password-on-macos
      - name: Copy Client debug symbols to Sentry, on macOS
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        working-directory: brave-browser/src/brave/whist
        env:
          SENTRY_ORG: whist
          SENTRY_PROJECT: protocol
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
        run: |
          # Uncomment this line to install sentry-cli. Since we're running on a self-hosted runner, we
          # comment it out after having run it once
          # curl -sL https://sentry.io/get-cli/ | bash
          if [[ "${{ runner.os }}" == "macOS" ]]; then
            sentry-cli upload-dif protocol/build-lib/client/build64/libWhistClient.dylib
            sentry-cli upload-dif protocol/build-lib/client/build64/WhistClient.debug
          elif [[ "${{ runner.os }}" == "Linux" ]]; then
            sentry-cli upload-dif protocol/build-lib/client/build64/libWhistClient.so
            sentry-cli upload-dif protocol/build-lib/client/build64/WhistClient.debug
          else
            echo "Unsupported OS for uploading Sentry debug symbols!"
            exit 1
          fi

      - name: Tar & Upload Whist Browser to AWS S3
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        working-directory: brave-browser/src/out
        run: |
          # On Arm builds, the arch gets appended to the output folder name
          if [[ "${{ matrix.config.target_arch }}" == "x64" ]]; then
            BUILD_OUTPUT_FOLDER="${{ env.build_type }}"
          else
            BUILD_OUTPUT_FOLDER="${{ env.build_type }}_${{ matrix.config.target_arch }}"
          fi
          tar -zcvf "${{ env.binary-tar-name }}" "$BUILD_OUTPUT_FOLDER/${{ env.executable_name }}"
          aws s3 cp "${{ env.binary-tar-name }}" "${{ env.s3-bucket-uri }}/${{ env.binary-tar-name }}"

      ###################################################################################

      - name: Manually Git Clone `whist` (for Slack notifications)
        if: ${{ runner.os == 'macOS' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule') && failure() }}
        run: |
          # Since this is a self-hosted runner, we manually check if the `whist` repo exists locally,
          # and if so we pull the latest changes. If it doesn't exist, we clone it.
          if [ -d "whist" ]; then
            echo "Entering whist..."
            cd whist

            # Log the branch, should always be `dev`, but we checkout just to be sure
            git branch
            git checkout dev
            git pull
            git branch
          else
            git clone "https://${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}@github.com/whisthq/whist.git" whist
          fi

      - name: Setup Python-based Notifications
        if: ${{ runner.os == 'macOS' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule') && failure() }}
        working-directory: whist/.github/workflows/helpers
        run: ./notifications/setup_notifications.sh false

      - name: Notify Slack on Workflow Error (Only on Push/Workflow_dispatch Events)
        if: ${{ runner.os == 'macOS' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch' || github.event_name == 'schedule') && failure() }}
        shell: python3 {0}
        run: |
          from notifications.slack_bot import slack_post
          SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"
          BODY = f"@releases :rotating_light: Failed to deploy Whist Browser to AWS S3, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

  #######################################################################################
  #######################################################################################

  # Whist Browser: Update Version Number
  # Set the New Whist version number in our configuration database, through Hasura
  whist-browser-update-version-number:
    name: "Whist Browser: Set New Version Number in Config Database"
    runs-on: ubuntu-20.04
    concurrency: whist-browser-update-version-number-${{ github.ref }}
    needs:
      [
        whist-publish-build-config,
        whist-browser-retrieve-version-number,
        whist-browser-publish-build-s3,
      ]

    # Only run whist-browser deployment if none of the previous steps failed
    if: |
      always() &&
      (needs.whist-browser-retrieve-version-number.result == 'success') &&
      (needs.whist-browser-publish-build-s3.result == 'success')

    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3

      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Update Config Database version with the new version
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        run: |
          BRANCH_NAME="${{ needs.whist-publish-build-config.outputs.branch }}"
          ACCESS_KEY='${{ secrets.HASURA_GRAPHQL_ACCESS_KEY_CONFIG }}'

          # curl GraphQL API to set new micro/staging_rc/dev_rc version number and git commit hash in config database
          if [[ "$BRANCH_NAME" == "prod" ]]; then
            curl -X POST \
            -H "Content-Type: application/json" \
            -H "X-Hasura-Admin-Secret: $ACCESS_KEY" \
            --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {micro: ${{ needs.whist-browser-retrieve-version-number.outputs.new_micro_version }}, staging_rc: ${{ needs.whist-browser-retrieve-version-number.outputs.new_staging_rc_version }}, dev_rc: ${{ needs.whist-browser-retrieve-version-number.outputs.new_dev_rc_version }}, prod_commit_hash: \\\"${{ github.sha }}\\\"}) { id } }\" }" \
            https://config-database.whist.com/v1/graphql
          elif [[ "$BRANCH_NAME" == "staging" ]]; then
            curl -X POST \
            -H "Content-Type: application/json" \
            -H "X-Hasura-Admin-Secret: $ACCESS_KEY" \
            --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {staging_rc: ${{ needs.whist-browser-retrieve-version-number.outputs.new_staging_rc_version }}, staging_commit_hash: \\\"${{ github.sha }}\\\"}) { id } }\" }" \
            https://config-database.whist.com/v1/graphql
          elif [[ "$BRANCH_NAME" == "dev" ]]; then
            curl -X POST \
            -H "Content-Type: application/json" \
            -H "X-Hasura-Admin-Secret: $ACCESS_KEY" \
            --data "{ \"query\": \"mutation { update_desktop_app_version_by_pk(pk_columns: {id: 1}, _set: {dev_rc: ${{ needs.whist-browser-retrieve-version-number.outputs.new_dev_rc_version }}, dev_commit_hash: \\\"${{ github.sha }}\\\"}) { id } }\" }" \
            https://config-database.whist.com/v1/graphql
          fi

      - name: Notify Slack on Publishing Whist Desktop Browser Success
        shell: python3 {0}
        if: needs.whist-browser-publish-build-s3.result == 'success'
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
            WEBSITE_URL = "https://whist.com"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
            WEBSITE_URL = "https://staging.whist.com"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"
            WEBSITE_URL = "https://dev.whist.com"

          from notifications.slack_bot import slack_post
          TITLE = ":chromium: Windows & macOS Whist Desktop Browser Deployed :chromium:"
          BODY = f"Windows & macOS Whist Desktop Browser deployed via upload to AWS S3 on branch: `${{ needs.whist-publish-build-config.outputs.branch }}` - You can download them from {WEBSITE_URL} (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)

  #######################################################################################
  #######################################################################################

  # Scaling Service: Deploy & Upgrade Image
  # Push the scaling service subtree to the appropriate Heroku app. This will also
  # automatically start the image swapover event on the scaling service.
  scaling-service-deploy:
    name: "Scaling Service: Deploy & Upgrade Image"
    runs-on: ubuntu-20.04
    concurrency: scaling-service-deploy-${{ github.ref }}
    needs:
      [
        whist-publish-build-config,
        mandelboxes-publish-ghcr,
        amis-publish-aws,
        auth0-deploy-rules,
        terraform-deploy,
      ]

    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # need to get full history for splitsh-lite

      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Authenticate Heroku
        run: |
          cat > ~/.netrc << EOF
          machine api.heroku.com
            login developers@whist.com
            password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
          machine git.heroku.com
            login developers@whist.com
            password ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
          EOF

      - name: Set up Go Environment
        uses: actions/setup-go@v3.2.1
        with:
          go-version: "1.18"

      - name: Authenticate Go commands with GitHub
        env:
          GH_USERNAME: ${{ secrets.GHA_USERNAME }}
          GH_PAT: ${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
        run: git config --global url.https://$GH_USERNAME:$GH_PAT@github.com/.insteadOf https://github.com/

      - name: Build Backend Services
        working-directory: backend/services
        env:
          HEROKU_USER: developers@whist.com
          HEROKU_APIKEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
        run: make build

      - name: Add Heroku Remote
        env:
          HEROKU_API_KEY: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
        run: |
          if [[ ${{ needs.whist-publish-build-config.outputs.branch }} == dev ]]; then
            HEROKU_APP_NAME=whist-dev-scaling-service
          elif [[ ${{ needs.whist-publish-build-config.outputs.branch }} == staging ]]; then
            HEROKU_APP_NAME=whist-staging-scaling-service
          elif [[ ${{ needs.whist-publish-build-config.outputs.branch }} == prod ]]; then
            HEROKU_APP_NAME=whist-prod-scaling-service
          else
            echo 'Error: Invalid branch' && false
          fi
          echo "HEROKU_APP_NAME=$HEROKU_APP_NAME" >> $GITHUB_ENV

          heroku git:remote --app $HEROKU_APP_NAME --remote heroku-whist-scaling-service

      - name: Configure git for Scaling Service deploy script
        run: |
          # Set the author of the commit in whisthq/docs to be the user
          # who just pushed to the dev branch of the monorepo.
          git config user.name "${{ github.event.pusher.name }}"
          git config user.email "${{ github.event.pusher.email }}"
          # Authenticate Git as Phil with GitHub
          git config credential.helper store
          git credential approve <<EOF
          protocol=https
          host=github.com
          username=phil@whist.com
          password=${{ secrets.GHA_PERSONAL_ACCESS_TOKEN }}
          EOF

      - name: Diff database schema with local schema.sql
        id: db-diff
        env:
          HEROKU_API_TOKEN: ${{ secrets.HEROKU_DEVELOPER_API_KEY }}
          HEROKU_APP_NAME: ${{ env.HEROKU_APP_NAME }}
        uses: ./.github/actions/db-migration

      - name: Deploy the Scaling Service,  Start image upgrade and Migrate database schema
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        shell: bash --noprofile --norc -eo pipefail {0}
        working-directory: backend/services/scaling-service
        run: ./deploy.sh "${{ needs.amis-publish-aws.outputs.region_to_ami_map }}" ${{ env.HEROKU_APP_NAME }} ${{ github.sha }} '${{ steps.db-diff.outputs.code }}' '${{ steps.db-diff.outputs.diff }}'

      - name: Notify Slack on Database Migration Performed
        shell: python3 {0}
        run: |
          import os
          import sys
          import urllib.parse
          from notifications.slack_bot import slack_post

          # This should be set by backend/services/scaling-service/deploy.sh
          if os.environ.get("DB_MIGRATION_PERFORMED", "false") != "true":
            sys.exit(0)

          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          TITLE = ":construction: Database Migration Performed :construction:"
          BODY = f"Database Schema Migration performed on branch: `${{ needs.whist-publish-build-config.outputs.branch }}` (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)

      - name: Notify Slack on Successful Scaling Service Deploy
        if: needs.whist-publish-build-config.outputs.publish == 'true'
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          SCALING_SERVICE_URL = "${{ needs.whist-publish-build-config.outputs.scaling_service_url }}"
          TITLE = ":party_parrot: Scaling Service Successfully Deployed :party_parrot:"
          BODY = f"Scaling Service at {SCALING_SERVICE_URL} deployed and started image upgrade on: `${{ needs.whist-publish-build-config.outputs.branch }}` (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)

      - name: Notify Slack on Job Error
        if: failure()
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          SCALING_SERVICE_URL = "${{ needs.whist-publish-build-config.outputs.scaling_service_url }}"
          BODY = f"@releases :rotating_light: Scaling Service at {SCALING_SERVICE_URL} failed to deploy, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)

  #######################################################################################
  #######################################################################################

  # Create GitHub Tag
  # Create a GitHub Tag when promoting to the `prod` branch
  # Runs if the entire deployment succeeds and the promotion is running on `prod`
  whist-create-github-release-tag:
    name: "Create GitHub Release Tag"
    runs-on: ubuntu-20.04
    needs:
      [
        whist-publish-build-config,
        auth0-deploy-rules,
        terraform-deploy,
        mandelboxes-publish-ghcr,
        amis-publish-aws,
        scaling-service-deploy,
        whist-browser-retrieve-version-number,
        whist-browser-publish-build-s3,
        whist-browser-update-version-number,
      ]
    if: needs.whist-publish-build-config.outputs.publish == 'true' && contains(fromJSON('["prod"]'), needs.whist-publish-build-config.outputs.branch)
    steps:
      - name: Checkout Git Repository
        uses: actions/checkout@v3

      - name: Setup Python-based notifications
        working-directory: .github/workflows/helpers
        run: ./notifications/setup_notifications.sh

      - name: Retrieve Today's Date
        run: echo "date=$(date)" >> $GITHUB_ENV

      - name: Create GitHub Tag
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ needs.whist-browser-retrieve-version-number.outputs.release_version }}
          body: Whist Production Release on ${{ env.date }}
          draft: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify Slack on Job Success
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          TITLE = ":github: Whist GitHub Release Completed :github:"
          BODY = "Deployment of Whist Version `v${{ needs.whist-browser-retrieve-version-number.outputs.release_version }}` on branch `${{ needs.whist-publish-build-config.outputs.branch }}` completed - See the generated GitHub Release here: https://github.com/whisthq/whist/releases/tag/v${{ needs.whist-browser-retrieve-version-number.outputs.release_version }} (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY, title=TITLE)

      - name: Notify Slack on Job Error
        if: failure()
        shell: python3 {0}
        run: |
          # Retrieve Slack webhook
          if "prod" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_PROD }}"
          elif "staging" in "${{ needs.whist-publish-build-config.outputs.branch }}":
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_STAGING }}"
          else:
            SLACK_WEBHOOK = "${{ secrets.SLACK_HOOKS_ENDPOINT_DEV }}"

          from notifications.slack_bot import slack_post
          BODY = "@releases :rotating_light: Deployment failed: could not create GitHub Release in `whist-create-github-release-tag` job, investigate immediately :rotating_light: (<https://github.com/whisthq/whist/actions/runs/${{ github.run_id }} | see logs>)"
          slack_post(slack_webhook=SLACK_WEBHOOK, body=BODY)
