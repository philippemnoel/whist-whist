# USAGE: docker build --file docker/Dockerfile ./
# - This assumes the build context is the repo root (see references to requirements.txt)

# Use official Python docker image to create the build artifacts.
# - The multi-stage pattern is being used since various python dependencies require compilation
#   to occur and we don't want to include the compiler toolchain in the final image.
# - Normally Alpine would be a good choice, but by using Debian (e.g. slim-buster)
#   it's easier to be compatible out of the box with various python dependencies
FROM python:3.6.10-slim-buster AS builder
# python:3.6.10 was validated to be the current version on Heroku by Ming by running
# `git push heroku SOME_BRANCH` (which returns status about the dyno) on 2020-07-09

# Create and change the repo directory
WORKDIR /repo

# Setup toolchain necessary for compilation activities in python dependencies
# hadolint ignore=DL3008,DL3015
RUN apt-get update \
 && apt-get install -y \
            build-essential \
            libssl-dev \
            libffi-dev \
            python-dev \
            libpq-dev

# Install python requirements
COPY requirements.txt ./
RUN pip install -r requirements.txt

# Use official Python docker image as base.
# - Specify full Python version to avoid disparities in images (i.e. if someone
#   builds this package after someone else when a new python version was released in
#   between)
FROM python:3.6.10-slim-buster

# Copy fully compiled python dependencies from the builder image into this final
# image
COPY --from=builder /usr/local/lib/python3.6/site-packages /usr/local/lib/python3.6/site-packages
# Copy the bin tools created for the python dependencies from the builder image
# into this final image to ease developer usage
COPY --from=builder /usr/local/bin /usr/local/bin

# Change to the app directory, which is a mounted Docker volume.
WORKDIR /app
ENTRYPOINT ["./stem-cell.sh"]
