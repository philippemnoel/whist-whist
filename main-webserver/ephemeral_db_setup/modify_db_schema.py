import os


def rename_x_to_y(x, y, file_data):
    """
    Rename x to y in file_data (create with readlines()). Modifies file_data directly.

    Args:
        x (str): old value
        y (str): new value
        file_data (List[str]): lines of original file
    """
    for i in range(len(file_data)):
        file_data[i] = file_data[i].replace(x, y)


def parse_role_and_db_from_url(postgres_url):
    """
    Get the role and db from a postgres URL.

    Args:
        postgres_url (str): a url in the form postgres://<role>:<password>@<host>:<port>/<database>

    Returns:
        role (str)
        db (str)
    """
    prefix = "postgres://"
    # grabs role and db from str, cut out prefix
    role = postgres_url[len(prefix) :].split(":")[0]
    db = postgres_url[len(prefix) :].split("/")[-1]
    return role, db


def change_schema():
    """
    Change the schema script download by fetch_db.sh. Heroku requires us to use role/db
    generated by them, so we need to change the schema script to work on the role/db
    given by Heroku in CI. This is also handy for review apps.

    Needs db_schema.sql in the current directory and env vars POSTGRES_FROM_URI
    and POSTGRES_TO_URI.
    """
    assert "db_schema.sql" in os.listdir(".")
    postgres_from_uri = os.getenv("POSTGRES_FROM_URI", "")
    postgres_to_uri = os.getenv("POSTGRES_TO_URI", "")
    assert postgres_from_uri != "" and postgres_to_uri != ""
    prefix = "postgres://"
    assert postgres_from_uri[: len(prefix)] == prefix
    assert postgres_to_uri[: len(prefix)] == prefix
    role, db = parse_role_and_db_from_url(postgres_from_uri)
    local_role, local_db = parse_role_and_db_from_url(postgres_to_uri)

    fp = open("db_schema.sql", "r")
    file_data = fp.readlines()
    fp.close()

    rename_x_to_y(role, local_role, file_data)
    rename_x_to_y(db, local_db, file_data)

    fp = open("db_schema.sql", "w")
    fp.writelines(file_data)
    fp.close()


if __name__ == "__main__":
    change_schema()
