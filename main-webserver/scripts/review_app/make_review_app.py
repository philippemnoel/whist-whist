import argparse
import shutil
import os
import subprocess

# move to directory where this file is written no matter where this is called from
CURRENT_DIR = os.path.join(os.getcwd(), os.path.dirname(__file__))

WEBSERVER_ROOT = os.path.join(CURRENT_DIR, "../..")

MONOREPO_ROOT = os.path.join(WEBSERVER_ROOT, "..")


def setup_branch():
    """
    Add files needed for review apps. Specifically:
    1. add app.json to monorepo root
    2. track file and commit
    3. push changes
    """
    print("Adding app.json to monorepo root")
    shutil.copy(os.path.join(WEBSERVER_ROOT, "app.json"), MONOREPO_ROOT)

    ret = subprocess.run(f"git add {os.path.join(MONOREPO_ROOT, 'app.json')}", shell=True)
    assert ret.returncode == 0

    ret = subprocess.run(
        'git commit -m "AUTOGENERATED COMMIT. This branch can now make a review app."', shell=True
    )
    assert ret.returncode == 0

    ret = subprocess.run("git push", shell=True)
    assert ret.returncode == 0

    print(
        "Success! Go to the Heroku UI and create a review app under the 'Pipeline' tab"
        " in fractal-server."
    )

    print(
        "It is recommended to disable automatic deploys. To do this, navigate to the "
        " 'Deploy' tab on the review app UI and disable automatic deploys. To make changes "
        " to webserver source, commit and push to this branch as you normally would. Then"
        " manually redeploy using the 'Manual deploy' feature under the 'Deploy' tab."
    )


def setup_review_app():
    """
    Setup the review app. Extra args:
    --app_name REVIEW_APP_NAME: given by Heroku when making a review app in the UI
    --use_dev_db: optionally provide to use the dev db with the review app

    Then do the following:
    1. Start the celery worker (disabled by default)
    2. Fetch the ephemeral db URL from the review app
    3. Setup the ephemeral db
    4. Make the review app use the ephemeral db
    """
    setup_review_app_parser = argparse.ArgumentParser(description="Setup the review app.")
    setup_review_app_parser.add_argument(
        "--app_name",
        required=True,
        help="Name of the Heroku Review App.",
    )
    setup_review_app_parser.add_argument(
        "--use_dev_db",
        action="store_true",  # True if --use-dev-db passed
        help="Use the dev db instead of ephemeral db.",
    )

    args, _ = setup_review_app_parser.parse_known_args()
    app_name = args.app_name
    use_dev_db = args.use_dev_db

    # enable the celery dyno, which is disabled by default
    ret = subprocess.run(f"heroku ps:scale celery=1:Hobby --app {app_name}", shell=True)
    assert ret.returncode == 0

    if use_dev_db:
        print(
            "Warning. The review app is running against the dev db."
            " Are you sure you want to do this?"
        )
        print("If not, rerun this and do not pass --use_dev_db.")
        return

    # capture stdout of this process so we get the eph db url
    print(f"Getting POSTGRES_EPHEMERAL_DB_URL from review app {app_name}...")
    ret = subprocess.run(
        f"heroku config:get POSTGRES_EPHEMERAL_DB_URL --app {app_name}",
        capture_output=True,
        shell=True,
    )
    assert ret.returncode == 0

    eph_db_url = ret.stdout.decode("utf-8").strip()

    # add DB_EXISTS=true and POSTGRES_URI=<eph_db_url> to env, then
    # run `ephemeral_db_setup/db_setup.sh`
    print(f"Settup up ephemeral db at {eph_db_url}")
    os.environ["DB_EXISTS"] = "true"
    os.environ["POSTGRES_URI"] = eph_db_url
    ret = subprocess.run(
        f"bash {os.path.join(WEBSERVER_ROOT, 'ephemeral_db_setup/db_setup.sh')}",
        start_new_session=True,
        shell=True,
    )
    assert ret.returncode == 0

    # override DATABASE_URL in the review app to be the eph db. This restarts the dyno
    # and makes it use the eph db.
    print("Overriding DATABASE_URL to be ephemeral db url.")
    ret = subprocess.run(
        f"heroku config:set DATABASE_URL={eph_db_url} --app {app_name}",
        start_new_session=True,
        shell=True,
    )
    assert ret.returncode == 0


def clean_branch():
    """
    Clean the branch of files added for review apps. Specifically:
    1. remove app.json from monorepo root
    2. add and commit changes
    3. push changes
    """
    print("Removing app.json from monorepo root")
    os.remove(os.path.join(MONOREPO_ROOT, "app.json"))

    ret = subprocess.run(
        "git add -u",
        shell=True,
    )
    assert ret.returncode == 0

    ret = subprocess.run(
        'git commit -m "AUTOGENERATED COMMIT. Undid the changes needed to run a review app."',
        shell=True,
    )
    assert ret.returncode == 0

    ret = subprocess.run("git push", shell=True)
    assert ret.returncode == 0


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Review app utility.")

    parser.add_argument(
        "--setup_branch",
        action="store_true",  # True iff --setup_branch passed
        help="Add files to this branch so that it can run a review app and commit them.",
    )
    parser.add_argument(
        "--setup_review_app",
        action="store_true",  # True iff --setup_review_app passed
        help="Setup the review app db.",
    )
    parser.add_argument(
        "--clean_branch",
        action="store_true",  # True iff --clean_branch passed
        help="Undoes setup_branch and commits.",
    )

    args, _ = parser.parse_known_args()

    # only one can be true
    assert (
        args.setup_branch + args.setup_review_app + args.clean_branch == 1
    ), "Only one of setup_branch, setup_review_app, clean_branch can be passed."

    if args.setup_branch:
        setup_branch()
    elif args.setup_review_app:
        setup_review_app()
    elif args.clean_branch:
        clean_branch()
    else:
        raise ValueError("Which arg was set? Not handled by utility.")
