from datetime import datetime as dt

import boto3
import logging

from celery import shared_task

from app.helpers.utils.general.logs import fractalLog
from app.models import db, ProtocolLog, UserContainer

BUCKET_NAME = "fractal-protocol-logs"


class BadSenderError(Exception):
    """Raised by uploadLogsToS3.

    Raised by uploadLogsToS3 when the sender argument is anything other than
    "client" or "server" (case-insensitive).
    """

    pass


class ContainerNotFoundError(Exception):
    """Raised by uploadLogsToS3.

    Raised by uploadLogsToS3 when the container identified by the ip and port
    arguments does not exist.
    """

    def __init__(self, ip, port):
        super().__init__(f"IP: {ip}, port: {port}")


@shared_task
def uploadLogsToS3(sender, version, connection_id, ip, port, aes_key, message):
    """Upload logs to S3.

    Arguments:
        sender (str): Either "client" or "server" (case-insensitive).
        version (str): The version of the protocol that is running within the
            task.
        connection_id (str): The unique connection identifier generated by the
            protocol.
        ip (str): The IP address of the instance on which the task is running.
        port (int): The port number on the instance that is forwarded to port
            32262 inside the container.
        aes_key (str): A secret key that the client uses to authenticate with
            the container and the container uses to authenticate with the web
            server.
        message (str): The log message to save to S3.

    Returns:
        None
    """

    source = sender.upper()

    # Perform input validation on the sender argument.
    if source not in ("CLIENT", "SERVER"):
        fractalLog(
            function="uploadLogsToS3",
            label=None,
            logs=f"Unrecognized sender {sender}",
            level=logging.ERROR,
        )

        raise BadSenderError(sender)

    container = UserContainer.query.filter_by(ip=ip, port_32262=port).first()

    # Make sure that the container with the specified networking attributes
    # exists.
    if not container or aes_key != container.secret_key:
        fractalLog(
            function="uploadLogsToS3",
            label=None,
            logs="Unable to find a matching container.",
            level=logging.ERROR,
        )

        raise ContainerNotFoundError(ip, port)

    # Do logging.
    username = container.user_id
    updated_at = dt.utcnow()
    filename = f"{source}{updated_at.strftime('%Y%m%d%H%M')}.txt"
    s3 = boto3.resource("s3")
    s3_object = s3.Object(BUCKET_NAME, filename)

    try:
        s3_object.put(ACL="public-read", Body=message, ContentType="text/plain")
    except Exception as e:  # TODO: Handle specfic exceptions.
        fractalLog(
            function="uploadLogsToS3",
            label=username,
            logs=f"Error uploading {sender.lower()} logs to S3: {e}",
            level=logging.ERROR,
        )

        raise e

    # Logs have been successfully uploaded to S3. Now we save to the database a
    # pointer to the S3 object.
    url = f"https://{BUCKET_NAME}.s3.amazonaws.com/{filename}"

    fractalLog(
        function="uploadLogsToS3",
        label=username,
        logs=f"Successfully saved logs to {filename}",
    )

    log = ProtocolLog.query.get(connection_id)

    if not log:
        log = ProtocolLog(
            connection_id=connection_id,
            timestamp=updated_at.timestamp() * 100000,
            user_id=username,
            version=version,
        )

        db.session.add(log)

    if source == "CLIENT":
        assert not log.client_logs

        log.client_logs = url
    else:
        assert source == "SERVER"
        assert not log.server_logs

        log.server_logs = url

    try:
        db.session.commit()
    except Exception as e:
        fractalLog(
            function="uploadLogsToS3",
            label=username,
            logs=(
                f"Failed to save a pointer to the {sender.lower()} logs at "
                f"{url} to the database: {e}"
            ),
            level=logging.ERROR,
        )

        raise e
