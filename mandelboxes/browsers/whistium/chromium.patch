diff --git a/chrome/browser/devtools/devtools_window.cc b/chrome/browser/devtools/devtools_window.cc
index a945456d4d15f..14b43c5bb4fd8 100644
--- a/chrome/browser/devtools/devtools_window.cc
+++ b/chrome/browser/devtools/devtools_window.cc
@@ -1090,10 +1090,12 @@ DevToolsWindow::DevToolsWindow(FrontendType frontend_type,
 // static
 bool DevToolsWindow::AllowDevToolsFor(Profile* profile,
                                       content::WebContents* web_contents) {
+  /* We want DevTools UI in kiosk mode on Whist
   // Don't allow DevTools UI in kiosk mode, because the DevTools UI would be
   // broken there. See https://crbug.com/514551 for context.
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))
     return false;
+  */
 
   return ChromeDevToolsManagerDelegate::AllowInspection(profile, web_contents);
 }
diff --git a/chrome/browser/renderer_context_menu/render_view_context_menu.cc b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
index e6efbf1e457ae..aba8b15bec745 100644
--- a/chrome/browser/renderer_context_menu/render_view_context_menu.cc
+++ b/chrome/browser/renderer_context_menu/render_view_context_menu.cc
@@ -1366,14 +1366,6 @@ void RenderViewContextMenu::AppendLinkItems() {
       AppendProtocolHandlerSubMenu();
     }
 
-    // Links to system web app can't be opened in incognito / off-the-record.
-    if (!link_system_app_type) {
-      menu_model_.AddItemWithStringId(
-          IDC_CONTENT_CONTEXT_OPENLINKOFFTHERECORD,
-          in_app ? IDS_CONTENT_CONTEXT_OPENLINKOFFTHERECORD_INAPP
-                 : IDS_CONTENT_CONTEXT_OPENLINKOFFTHERECORD);
-    }
-
     AppendOpenInWebAppLinkItems();
     AppendOpenWithLinkItems();
 
@@ -1755,6 +1747,10 @@ void RenderViewContextMenu::AppendExitFullscreenItem() {
   if (!browser)
     return;
 
+  // If kiosk mode, Whist has enabled the context menu so we must remove this option.
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))
+    return;
+
   // Only show item if in fullscreen mode.
   if (!browser->exclusive_access_manager()
            ->fullscreen_controller()
diff --git a/chrome/browser/ui/views/bookmarks/bookmark_context_menu.cc b/chrome/browser/ui/views/bookmarks/bookmark_context_menu.cc
index 116e2b842fcb7..238fa1cb005c6 100644
--- a/chrome/browser/ui/views/bookmarks/bookmark_context_menu.cc
+++ b/chrome/browser/ui/views/bookmarks/bookmark_context_menu.cc
@@ -81,9 +81,6 @@ void BookmarkContextMenu::InstallPreRunCallback(base::OnceClosure callback) {
 
 void BookmarkContextMenu::RunMenuAt(const gfx::Point& point,
                                     ui::MenuSourceType source_type) {
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))
-    return;
-
   if (!PreRunCallback().is_null())
     std::move(PreRunCallback()).Run();
 
diff --git a/chrome/browser/ui/views/page_action/zoom_view.cc b/chrome/browser/ui/views/page_action/zoom_view.cc
index fba0a8ce686d1..a256348e4ce9f 100644
--- a/chrome/browser/ui/views/page_action/zoom_view.cc
+++ b/chrome/browser/ui/views/page_action/zoom_view.cc
@@ -34,6 +34,9 @@ void ZoomView::UpdateImpl() {
 }
 
 bool ZoomView::ShouldBeVisible(bool can_show_bubble) const {
+  // We don't want the server to ever show the zoom bubble view
+  return false;
+  /*
   if (delegate()->ShouldHidePageActionIcons())
     return false;
 
@@ -47,6 +50,7 @@ bool ZoomView::ShouldBeVisible(bool can_show_bubble) const {
   zoom::ZoomController* zoom_controller =
       zoom::ZoomController::FromWebContents(GetWebContents());
   return zoom_controller && !zoom_controller->IsAtDefaultZoom();
+  */
 }
 
 bool ZoomView::HasAssociatedBubble() const {
diff --git a/chrome/browser/ui/views/renderer_context_menu/render_view_context_menu_views.cc b/chrome/browser/ui/views/renderer_context_menu/render_view_context_menu_views.cc
index dd729e8186d03..aeed067f3f4f6 100644
--- a/chrome/browser/ui/views/renderer_context_menu/render_view_context_menu_views.cc
+++ b/chrome/browser/ui/views/renderer_context_menu/render_view_context_menu_views.cc
@@ -362,9 +362,6 @@ void RenderViewContextMenuViews::ExecOpenInReadAnything() {
 }
 
 void RenderViewContextMenuViews::Show() {
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode))
-    return;
-
   // Menus need a Widget to work. If we're not the active tab we won't
   // necessarily be in a widget.
   views::Widget* top_level_widget = GetTopLevelWidget();
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index b74b4c2028ccb..1e61c0718d691 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -3281,6 +3281,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     switches::kEnableTouchDragDrop,
     switches::kEnableUnsafeFastJSCalls,
     switches::kEnableUnsafeWebGPU,
+    switches::kEnableGpuCommandStreaming,
     switches::kEnableViewport,
     switches::kEnableVtune,
     switches::kEnableWebGLDeveloperExtensions,
diff --git a/gpu/command_buffer/client/client_transfer_cache.cc b/gpu/command_buffer/client/client_transfer_cache.cc
index 00d7a7058340d..3dc5d937f7e25 100644
--- a/gpu/command_buffer/client/client_transfer_cache.cc
+++ b/gpu/command_buffer/client/client_transfer_cache.cc
@@ -3,6 +3,7 @@
 // found in the LICENSE file.
 
 #include "gpu/command_buffer/client/client_transfer_cache.h"
+#include "gpu/command_buffer/client/cmd_buffer_helper.h"
 
 namespace gpu {
 
@@ -51,12 +52,16 @@ void ClientTransferCache::UnmapAndCreateEntry(uint32_t type, uint32_t id) {
 
   if (mapped_ptr_) {
     DCHECK(!transfer_buffer_ptr_);
+    client_->cmd_buffer_helper()->SendBufferToWhist(CommandBufferType::TRANSFER_CACHE,
+                  mapped_ptr_->address(), mapped_ptr_->size());
     client_->IssueCreateTransferCacheEntry(
         type, id, handle.shm_id(), handle.byte_offset(), mapped_ptr_->shm_id(),
         mapped_ptr_->offset(), mapped_ptr_->size());
     mapped_ptr_ = absl::nullopt;
   } else {
     DCHECK(!mapped_ptr_);
+    client_->cmd_buffer_helper()->SendBufferToWhist(CommandBufferType::TRANSFER_CACHE,
+                  transfer_buffer_ptr_->address(), transfer_buffer_ptr_->size());
     client_->IssueCreateTransferCacheEntry(
         type, id, handle.shm_id(), handle.byte_offset(),
         transfer_buffer_ptr_->shm_id(), transfer_buffer_ptr_->offset(),
diff --git a/gpu/command_buffer/client/cmd_buffer_helper.cc b/gpu/command_buffer/client/cmd_buffer_helper.cc
index 8813dac7f22d0..200e00f2f46a4 100644
--- a/gpu/command_buffer/client/cmd_buffer_helper.cc
+++ b/gpu/command_buffer/client/cmd_buffer_helper.cc
@@ -7,8 +7,13 @@
 #include "gpu/command_buffer/client/cmd_buffer_helper.h"
 
 #include <stdint.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
 
 #include <algorithm>
+#include "base/command_line.h"
 #include "base/logging.h"
 #include "base/strings/stringprintf.h"
 #include "base/threading/thread_task_runner_handle.h"
@@ -19,10 +24,14 @@
 #include "base/trace_event/trace_event.h"
 #include "gpu/command_buffer/common/buffer.h"
 #include "gpu/command_buffer/common/command_buffer.h"
+#include "gpu/command_buffer/service/common_decoder.h"
 #include "gpu/command_buffer/common/constants.h"
+#include "gpu/config/gpu_switches.h"
 
 namespace gpu {
 
+#define IPC_FILE "/home/whist/gpu_commands"
+
 CommandBufferHelper::CommandBufferHelper(CommandBuffer* command_buffer)
     : command_buffer_(command_buffer) {}
 
@@ -104,6 +113,32 @@ bool CommandBufferHelper::AllocateRingBuffer() {
 
 void CommandBufferHelper::SetGetBuffer(int32_t id,
                                        scoped_refptr<Buffer> buffer) {
+  is_renderer_process_ = base::trace_event::TraceLog::GetInstance()->process_name() == "Renderer";
+  const base::CommandLine& command_line = *base::CommandLine::ForCurrentProcess();
+
+  if (is_renderer_process_ && command_line.HasSwitch(switches::kEnableGpuCommandStreaming) &&
+      GetCommandBufferType() == CommandBufferType::RASTER && sock_fd_ == -1) {
+    if ((sock_fd_ = socket (AF_UNIX, SOCK_SEQPACKET, 0)) == -1) {
+      int err_socket = errno;
+      LOG(ERROR) << "Could not open the socket for GPU command streaming, error=" << strerror(err_socket);
+      return;
+    }
+    LOG(INFO) << "Successfully opened the socket for GPU command streaming";
+
+    struct sockaddr_un socket_address;
+    memset (&socket_address, 0, sizeof (struct sockaddr_un));
+    socket_address.sun_family = AF_UNIX;
+    strncpy (socket_address.sun_path, IPC_FILE, sizeof (socket_address.sun_path) - 1);
+
+    if (connect (sock_fd_, (const struct sockaddr *) &socket_address, sizeof (struct sockaddr_un)) == -1) {
+      sock_fd_ = -1;
+      int err_socket = errno;
+      LOG(ERROR) << "Could not connect to the socket for GPU command streaming, error=" << strerror(err_socket);
+      return;
+    }
+    LOG(INFO) << "Successfully connected the socket for GPU command streaming";
+  }
+
   command_buffer_->SetGetBuffer(id);
   ring_buffer_ = std::move(buffer);
   ring_buffer_id_ = id;
@@ -117,6 +152,7 @@ void CommandBufferHelper::SetGetBuffer(int32_t id,
   // No need to query it through IPC.
   put_ = 0;
   last_flush_put_ = 0;
+  last_whist_put_ = 0;
   last_ordering_barrier_put_ = 0;
   cached_get_offset_ = 0;
   service_on_old_buffer_ = true;
@@ -135,6 +171,9 @@ void CommandBufferHelper::FreeRingBuffer() {
 
 gpu::ContextResult CommandBufferHelper::Initialize(uint32_t ring_buffer_size) {
   ring_buffer_size_ = ring_buffer_size;
+  if (socket_buffer != NULL)
+    free(socket_buffer);
+  socket_buffer = (char *)malloc(ring_buffer_size_);
   if (!AllocateRingBuffer()) {
     // This would fail if CreateTransferBuffer fails, which will not fail for
     // transient reasons such as context loss. See http://crrev.com/c/720269
@@ -147,6 +186,8 @@ gpu::ContextResult CommandBufferHelper::Initialize(uint32_t ring_buffer_size) {
 
 CommandBufferHelper::~CommandBufferHelper() {
   FreeRingBuffer();
+  if (socket_buffer != NULL)
+    free(socket_buffer);
 }
 
 void CommandBufferHelper::UpdateCachedState(const CommandBuffer::State& state) {
@@ -169,6 +210,34 @@ bool CommandBufferHelper::WaitForGetOffsetInRange(int32_t start, int32_t end) {
   return !context_lost_;
 }
 
+void CommandBufferHelper::SendBufferToWhist(CommandBufferType type, void* buffer,
+                                            int32_t shm_size) {
+  if (sock_fd_ == -1)
+    return;
+  if (shm_size <= 0)
+    return;
+  socket_buffer[0] = static_cast<char>(type);
+  memcpy(socket_buffer + 1, buffer, shm_size);
+  if (write(sock_fd_, socket_buffer, shm_size + 1) == -1) {
+      DLOG(ERROR) << "Could not send the command data to Whist";
+  }
+}
+
+void CommandBufferHelper::SendCommandsToWhist() {
+  if (sock_fd_ == -1)
+    return;
+  DCHECK(put_ >= last_whist_put_);
+  if (put_ == last_whist_put_)
+    return;
+  socket_buffer[0] = static_cast<char>(GetCommandBufferType());
+  int size = (put_ - last_whist_put_) * sizeof (CommandBufferEntry);
+  memcpy(socket_buffer + 1, &entries_[last_whist_put_], size);
+  if (write(sock_fd_, socket_buffer, size + 1) == -1) {
+      DLOG(ERROR) << "Could not send the command buffer to Whist";
+  }
+  last_whist_put_ = put_;
+}
+
 void CommandBufferHelper::Flush() {
   TRACE_EVENT0("gpu", "CommandBufferHelper::Flush");
   // Wrap put_ before flush.
@@ -177,6 +246,15 @@ void CommandBufferHelper::Flush() {
 
   if (HaveRingBuffer()) {
     last_flush_time_ = base::TimeTicks::Now();
+    SendCommandsToWhist();
+    if (sock_fd_ != -1) {
+      // Flush is sent as a separate packet type, so that CommandBufferHelper::Flush()
+      // can be called at the appropriate time on the client-side browser.
+      socket_buffer[0] = static_cast<char>(CommandBufferType::FLUSH);
+      if (write(sock_fd_, socket_buffer, 1) == -1) {
+          DLOG(ERROR) << "Could not send the command buffer to Whist";
+      }
+    }
     last_flush_put_ = put_;
     last_ordering_barrier_put_ = put_;
     command_buffer_->Flush(put_);
@@ -244,6 +322,10 @@ int32_t CommandBufferHelper::InsertToken() {
   if (cmd) {
     token_ = (token_ + 1) & 0x7FFFFFFF;
     cmd->Init(token_);
+    // SetToken command is immediately, so that the corresponding
+    // shared memory buffers can be freed on the client side before
+    // the next shared memory buffer packet is sent from the server.
+    SendCommandsToWhist();
     if (token_ == 0) {
       TRACE_EVENT0("gpu", "CommandBufferHelper::InsertToken(wrapped)");
       bool finished = Finish();  // we wrapped
diff --git a/gpu/command_buffer/client/cmd_buffer_helper.h b/gpu/command_buffer/client/cmd_buffer_helper.h
index 5d0d6a9a8ed2b..89361a2d3a952 100644
--- a/gpu/command_buffer/client/cmd_buffer_helper.h
+++ b/gpu/command_buffer/client/cmd_buffer_helper.h
@@ -17,6 +17,7 @@
 #include "base/time/time.h"
 #include "base/trace_event/memory_dump_provider.h"
 #include "build/build_config.h"
+#include "gpu/command_buffer/client/transfer_buffer.h"
 #include "gpu/command_buffer/common/cmd_buffer_common.h"
 #include "gpu/command_buffer/common/command_buffer.h"
 #include "gpu/command_buffer/common/context_result.h"
@@ -35,6 +36,16 @@ const int kPeriodicFlushDelayInMicroseconds = 500;
 const int kAutoFlushSmall = 16;  // 1/16 of the buffer
 const int kAutoFlushBig = 2;     // 1/2 of the buffer
 
+enum class CommandBufferType {
+  GLES,
+  RASTER,
+  WEBGPU,
+  MEM,
+  TRANSFER_CACHE,
+  FONT,
+  FLUSH,
+};
+
 // Command buffer helper class. This class simplifies ring buffer management:
 // it will allocate the buffer, give it to the buffer interface, and let the
 // user add commands to it, while taking care of the synchronization (put and
@@ -204,6 +215,10 @@ class GPU_EXPORT CommandBufferHelper {
     if (cmd) {
       cmd->Init(token);
     }
+    // SetToken command is immediately, so that the corresponding
+    // shared memory buffers can be freed on the client side before
+    // the next shared memory buffer packet is sent from the server.
+    SendCommandsToWhist();
   }
 
   void SetBucketSize(uint32_t bucket_id, uint32_t size) {
@@ -215,14 +230,17 @@ class GPU_EXPORT CommandBufferHelper {
 
   void SetBucketData(uint32_t bucket_id,
                      uint32_t offset,
-                     uint32_t size,
-                     uint32_t shared_memory_id,
-                     uint32_t shared_memory_offset) {
+                     ScopedTransferBufferPtr &buffer) {
+    SendBufferToWhist(CommandBufferType::MEM, buffer.address(), buffer.size());
     cmd::SetBucketData* cmd = GetCmdSpace<cmd::SetBucketData>();
     if (cmd) {
-      cmd->Init(bucket_id, offset, size, shared_memory_id,
-                shared_memory_offset);
+      cmd->Init(bucket_id, offset, buffer.size(), buffer.shm_id(),
+                buffer.offset());
     }
+    // SetBucketData command is sent immediately, to preserve ordering of packets
+    // that depend on the shared memory data. Otherwise the shared memory buffer
+    // sent earlier will get overwritten by some other command's buffer.
+    SendCommandsToWhist();
   }
 
   void SetBucketDataImmediate(uint32_t bucket_id,
@@ -290,6 +308,11 @@ class GPU_EXPORT CommandBufferHelper {
 
   int32_t GetPutOffsetForTest() const { return put_; }
 
+  void SendBufferToWhist(CommandBufferType type, void* buffer, int32_t shm_size);
+  void SendCommandsToWhist();
+
+  virtual CommandBufferType GetCommandBufferType() const = 0;
+
  private:
   void CalcImmediateEntries(int waiting_count);
   bool AllocateRingBuffer();
@@ -348,6 +371,11 @@ class GPU_EXPORT CommandBufferHelper {
   // Can be used to track when prior commands have been flushed.
   uint32_t flush_generation_ = 0;
 
+  bool is_renderer_process_ = false;
+  int sock_fd_ = -1;
+  char *socket_buffer = NULL;
+  int32_t last_whist_put_ = 0;
+
   friend class CommandBufferHelperTest;
 };
 
diff --git a/gpu/command_buffer/client/gles2_cmd_helper.cc b/gpu/command_buffer/client/gles2_cmd_helper.cc
index 362cadf7eb59c..45b704c8af2c6 100644
--- a/gpu/command_buffer/client/gles2_cmd_helper.cc
+++ b/gpu/command_buffer/client/gles2_cmd_helper.cc
@@ -13,6 +13,10 @@ GLES2CmdHelper::GLES2CmdHelper(CommandBuffer* command_buffer)
 
 GLES2CmdHelper::~GLES2CmdHelper() = default;
 
+CommandBufferType GLES2CmdHelper::GetCommandBufferType() const {
+  return CommandBufferType::GLES;
+}
+
 }  // namespace gles2
 }  // namespace gpu
 
diff --git a/gpu/command_buffer/client/gles2_cmd_helper.h b/gpu/command_buffer/client/gles2_cmd_helper.h
index a403753f54999..6e032d3946997 100644
--- a/gpu/command_buffer/client/gles2_cmd_helper.h
+++ b/gpu/command_buffer/client/gles2_cmd_helper.h
@@ -24,6 +24,8 @@ class GPU_GLES2_EXPORT GLES2CmdHelper : public CommandBufferHelper {
 
   ~GLES2CmdHelper() override;
 
+  CommandBufferType GetCommandBufferType() const override;
+
   // Include the auto-generated part of this class. We split this because it
   // means we can easily edit the non-auto generated parts right here in this
   // file instead of having to edit some template or the code generator.
diff --git a/gpu/command_buffer/client/gles2_implementation.cc b/gpu/command_buffer/client/gles2_implementation.cc
index 7c33d18041938..8f6ce21210b08 100644
--- a/gpu/command_buffer/client/gles2_implementation.cc
+++ b/gpu/command_buffer/client/gles2_implementation.cc
@@ -7374,8 +7374,7 @@ bool GLES2Implementation::PackStringsToBucket(GLsizei count,
         DCHECK(copy_size + 1 == buffer.size());
         reinterpret_cast<char*>(buffer.address())[copy_size] = 0;
       }
-      helper_->SetBucketData(kResultBucketId, offset, buffer.size(),
-                             buffer.shm_id(), buffer.offset());
+      helper_->SetBucketData(kResultBucketId, offset, buffer);
       offset += buffer.size();
       src += buffer.size();
       size -= buffer.size();
diff --git a/gpu/command_buffer/client/implementation_base.cc b/gpu/command_buffer/client/implementation_base.cc
index 0492f62a9f77e..1414b6bb4350f 100644
--- a/gpu/command_buffer/client/implementation_base.cc
+++ b/gpu/command_buffer/client/implementation_base.cc
@@ -331,8 +331,7 @@ void ImplementationBase::SetBucketContents(uint32_t bucket_id,
       }
       memcpy(buffer.address(), static_cast<const int8_t*>(data) + offset,
              buffer.size());
-      helper_->SetBucketData(bucket_id, offset, buffer.size(), buffer.shm_id(),
-                             buffer.offset());
+      helper_->SetBucketData(bucket_id, offset, buffer);
       offset += buffer.size();
       size -= buffer.size();
     }
diff --git a/gpu/command_buffer/client/raster_cmd_helper.cc b/gpu/command_buffer/client/raster_cmd_helper.cc
index 191dfa3b36a68..defe69573e6b3 100644
--- a/gpu/command_buffer/client/raster_cmd_helper.cc
+++ b/gpu/command_buffer/client/raster_cmd_helper.cc
@@ -12,5 +12,9 @@ RasterCmdHelper::RasterCmdHelper(CommandBuffer* command_buffer)
 
 RasterCmdHelper::~RasterCmdHelper() = default;
 
+CommandBufferType RasterCmdHelper::GetCommandBufferType() const {
+  return CommandBufferType::RASTER;
+}
+
 }  // namespace raster
 }  // namespace gpu
diff --git a/gpu/command_buffer/client/raster_cmd_helper.h b/gpu/command_buffer/client/raster_cmd_helper.h
index 0dc93d8606b51..cb772dcafde34 100644
--- a/gpu/command_buffer/client/raster_cmd_helper.h
+++ b/gpu/command_buffer/client/raster_cmd_helper.h
@@ -24,6 +24,8 @@ class RASTER_EXPORT RasterCmdHelper : public CommandBufferHelper {
 
   ~RasterCmdHelper() override;
 
+  CommandBufferType GetCommandBufferType() const override;
+
 // Include the auto-generated part of this class. We split this because it
 // means we can easily edit the non-auto generated parts right here in this
 // file instead of having to edit some template or the code generator.
diff --git a/gpu/command_buffer/client/raster_implementation.cc b/gpu/command_buffer/client/raster_implementation.cc
index 2a43b28a56c2d..a391674782466 100644
--- a/gpu/command_buffer/client/raster_implementation.cc
+++ b/gpu/command_buffer/client/raster_implementation.cc
@@ -217,6 +217,8 @@ class RasterImplementation::TransferCacheSerializeHelperImpl final
     bool succeeded = entry.Serialize(
         base::make_span(reinterpret_cast<uint8_t*>(memory), bytes_remaining));
     DCHECK(succeeded);
+    ri_->helper_->SendBufferToWhist(CommandBufferType::TRANSFER_CACHE, memory, bytes_to_write);
+
     ri_->transfer_cache_.AddTransferCacheEntry(
         entry.UnsafeType(), entry.Id(), buffer->shm_id(),
         buffer->offset() + memory_offset, bytes_to_write);
@@ -808,6 +810,7 @@ void RasterImplementation::IssueCreateTransferCacheEntry(
   helper_->CreateTransferCacheEntryINTERNAL(entry_type, entry_id, handle_shm_id,
                                             handle_shm_offset, data_shm_id,
                                             data_shm_offset, data_size);
+  helper_->SendCommandsToWhist();
 }
 
 void RasterImplementation::IssueDeleteTransferCacheEntry(GLuint entry_type,
@@ -1188,9 +1191,16 @@ void RasterImplementation::UnmapRasterCHROMIUM(uint32_t raster_written_size,
   }
 
   if (raster_written_size != 0u) {
+    helper_->SendBufferToWhist(CommandBufferType::MEM, raster_mapped_buffer_->address(),
+                               raster_written_size);
+    if (font_mapped_buffer_) {
+      helper_->SendBufferToWhist(CommandBufferType::FONT, font_mapped_buffer_->address(),
+                                 font_shm_size);
+    }
     helper_->RasterCHROMIUM(
         raster_mapped_buffer_->shm_id(), raster_mapped_buffer_->offset(),
         raster_written_size, font_shm_id, font_shm_offset, font_shm_size);
+    helper_->SendCommandsToWhist();
   }
 
   raster_mapped_buffer_ = absl::nullopt;
diff --git a/gpu/command_buffer/client/raster_implementation.h b/gpu/command_buffer/client/raster_implementation.h
index fdd547e776b95..f36db34772074 100644
--- a/gpu/command_buffer/client/raster_implementation.h
+++ b/gpu/command_buffer/client/raster_implementation.h
@@ -276,6 +276,7 @@ class RASTER_EXPORT RasterImplementation : public RasterInterface,
   std::unique_ptr<cc::TransferCacheSerializeHelper>
   CreateTransferCacheHelperForTesting();
   void SetRasterMappedBufferForTesting(ScopedTransferBufferPtr buffer);
+  raw_ptr<RasterCmdHelper> helper_;
 
  private:
   class TransferCacheSerializeHelperImpl;
@@ -398,7 +399,6 @@ class RASTER_EXPORT RasterImplementation : public RasterInterface,
   void FailGLError(GLenum /* error */) {}
 #endif
 
-  raw_ptr<RasterCmdHelper> helper_;
   std::string last_error_;
   gles2::DebugMarkerManager debug_marker_manager_;
   std::string this_in_hex_;
diff --git a/gpu/command_buffer/client/webgpu_cmd_helper.cc b/gpu/command_buffer/client/webgpu_cmd_helper.cc
index e306d38aed27e..8354499592fed 100644
--- a/gpu/command_buffer/client/webgpu_cmd_helper.cc
+++ b/gpu/command_buffer/client/webgpu_cmd_helper.cc
@@ -12,5 +12,9 @@ WebGPUCmdHelper::WebGPUCmdHelper(CommandBuffer* command_buffer)
 
 WebGPUCmdHelper::~WebGPUCmdHelper() = default;
 
+CommandBufferType WebGPUCmdHelper::GetCommandBufferType() const {
+  return CommandBufferType::WEBGPU;
+}
+
 }  // namespace webgpu
 }  // namespace gpu
diff --git a/gpu/command_buffer/client/webgpu_cmd_helper.h b/gpu/command_buffer/client/webgpu_cmd_helper.h
index 5e7ffd1d2230f..f75ea6dbf0b52 100644
--- a/gpu/command_buffer/client/webgpu_cmd_helper.h
+++ b/gpu/command_buffer/client/webgpu_cmd_helper.h
@@ -24,6 +24,8 @@ class WEBGPU_EXPORT WebGPUCmdHelper : public CommandBufferHelper {
 
   ~WebGPUCmdHelper() override;
 
+  CommandBufferType GetCommandBufferType() const override;
+
 // Include the auto-generated part of this class. We split this because it
 // means we can easily edit the non-auto generated parts right here in this
 // file instead of having to edit some template or the code generator.
diff --git a/gpu/config/gpu_switches.cc b/gpu/config/gpu_switches.cc
index 17d91d4bb66ca..a60caa3875fe2 100644
--- a/gpu/config/gpu_switches.cc
+++ b/gpu/config/gpu_switches.cc
@@ -117,4 +117,7 @@ const char kForceBrowserCrashOnGpuCrash[] = "force-browser-crash-on-gpu-crash";
 // Override value for the GPU watchdog timeout in seconds.
 const char kGpuWatchdogTimeoutSeconds[] = "gpu-watchdog-timeout-seconds";
 
+// Enables GPU command streaming for cloud tabs
+const char kEnableGpuCommandStreaming[] = "enable-gpu-command-streaming";
+
 }  // namespace switches
diff --git a/gpu/config/gpu_switches.h b/gpu/config/gpu_switches.h
index f4d43cd83e5d2..79d05dd3e2b8a 100644
--- a/gpu/config/gpu_switches.h
+++ b/gpu/config/gpu_switches.h
@@ -38,6 +38,7 @@ GPU_EXPORT extern const char kVulkanHeapMemoryLimitMb[];
 GPU_EXPORT extern const char kVulkanSyncCpuMemoryLimitMb[];
 GPU_EXPORT extern const char kForceBrowserCrashOnGpuCrash[];
 GPU_EXPORT extern const char kGpuWatchdogTimeoutSeconds[];
+GPU_EXPORT extern const char kEnableGpuCommandStreaming[];
 
 }  // namespace switches
 
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index 5c3a90ee7fcdc..9f6eaaea42675 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -152,8 +152,13 @@ config("skia_library_config") {
   # Settings for text blitting, chosen to approximate the system browser.
   if (is_linux || is_chromeos) {
     defines += [
-      "SK_GAMMA_EXPONENT=1.2",
-      "SK_GAMMA_CONTRAST=0.2",
+#     Setting the value of contrast, exponent and srgb same as mac, so that the
+#     strikecache will have the same key during font data deserialization on the
+#     mac client browser.
+#      "SK_GAMMA_EXPONENT=1.2",
+#      "SK_GAMMA_CONTRAST=0.2",
+      "SK_GAMMA_SRGB",
+      "SK_GAMMA_CONTRAST=0.0",
     ]
   } else if (is_android) {
     defines += [
diff --git a/third_party/blink/renderer/core/editing/editing_behavior.cc b/third_party/blink/renderer/core/editing/editing_behavior.cc
index 6b7a35b5b83db..2537f0737c936 100644
--- a/third_party/blink/renderer/core/editing/editing_behavior.cc
+++ b/third_party/blink/renderer/core/editing/editing_behavior.cc
@@ -44,7 +44,7 @@ const unsigned kCtrlKey = WebInputEvent::kControlKey;
 const unsigned kAltKey = WebInputEvent::kAltKey;
 const unsigned kShiftKey = WebInputEvent::kShiftKey;
 const unsigned kMetaKey = WebInputEvent::kMetaKey;
-#if BUILDFLAG(IS_MAC)
+#if 1 //BUILDFLAG(IS_MAC)
 // Aliases for the generic key defintions to make kbd shortcuts definitions more
 // readable on OS X.
 const unsigned kOptionKey = kAltKey;
@@ -87,7 +87,7 @@ struct DomKeyKeyDownEntry {
 const KeyboardCodeKeyDownEntry kKeyboardCodeKeyDownEntries[] = {
     {VKEY_LEFT, 0, "MoveLeft"},
     {VKEY_LEFT, kShiftKey, "MoveLeftAndModifySelection"},
-#if BUILDFLAG(IS_MAC)
+#if 1 //BUILDFLAG(IS_MAC)
     {VKEY_LEFT, kOptionKey, "MoveWordLeft"},
     {VKEY_LEFT, kOptionKey | kShiftKey, "MoveWordLeftAndModifySelection"},
 #else
@@ -96,7 +96,7 @@ const KeyboardCodeKeyDownEntry kKeyboardCodeKeyDownEntries[] = {
 #endif
     {VKEY_RIGHT, 0, "MoveRight"},
     {VKEY_RIGHT, kShiftKey, "MoveRightAndModifySelection"},
-#if BUILDFLAG(IS_MAC)
+#if 1 //BUILDFLAG(IS_MAC)
     {VKEY_RIGHT, kOptionKey, "MoveWordRight"},
     {VKEY_RIGHT, kOptionKey | kShiftKey, "MoveWordRightAndModifySelection"},
 #else
@@ -109,7 +109,7 @@ const KeyboardCodeKeyDownEntry kKeyboardCodeKeyDownEntries[] = {
     {VKEY_DOWN, 0, "MoveDown"},
     {VKEY_DOWN, kShiftKey, "MoveDownAndModifySelection"},
     {VKEY_NEXT, kShiftKey, "MovePageDownAndModifySelection"},
-#if !BUILDFLAG(IS_MAC)
+#if 0 //!BUILDFLAG(IS_MAC)
     {VKEY_UP, kCtrlKey, "MoveParagraphBackward"},
     {VKEY_UP, kCtrlKey | kShiftKey, "MoveParagraphBackwardAndModifySelection"},
     {VKEY_DOWN, kCtrlKey, "MoveParagraphForward"},
@@ -119,32 +119,32 @@ const KeyboardCodeKeyDownEntry kKeyboardCodeKeyDownEntries[] = {
 #endif
     {VKEY_HOME, 0, "MoveToBeginningOfLine"},
     {VKEY_HOME, kShiftKey, "MoveToBeginningOfLineAndModifySelection"},
-#if BUILDFLAG(IS_MAC)
+#if 1 //BUILDFLAG(IS_MAC)
     {VKEY_PRIOR, kOptionKey, "MovePageUp"},
     {VKEY_NEXT, kOptionKey, "MovePageDown"},
 #endif
-#if !BUILDFLAG(IS_MAC)
+#if 0 //!BUILDFLAG(IS_MAC)
     {VKEY_HOME, kCtrlKey, "MoveToBeginningOfDocument"},
     {VKEY_HOME, kCtrlKey | kShiftKey,
      "MoveToBeginningOfDocumentAndModifySelection"},
 #endif
     {VKEY_END, 0, "MoveToEndOfLine"},
     {VKEY_END, kShiftKey, "MoveToEndOfLineAndModifySelection"},
-#if !BUILDFLAG(IS_MAC)
+#if 0 //!BUILDFLAG(IS_MAC)
     {VKEY_END, kCtrlKey, "MoveToEndOfDocument"},
     {VKEY_END, kCtrlKey | kShiftKey, "MoveToEndOfDocumentAndModifySelection"},
 #endif
     {VKEY_BACK, 0, "DeleteBackward"},
     {VKEY_BACK, kShiftKey, "DeleteBackward"},
     {VKEY_DELETE, 0, "DeleteForward"},
-#if BUILDFLAG(IS_MAC)
+#if 1 //BUILDFLAG(IS_MAC)
     {VKEY_BACK, kOptionKey, "DeleteWordBackward"},
     {VKEY_DELETE, kOptionKey, "DeleteWordForward"},
 #else
     {VKEY_BACK, kCtrlKey, "DeleteWordBackward"},
     {VKEY_DELETE, kCtrlKey, "DeleteWordForward"},
 #endif
-#if BUILDFLAG(IS_MAC)
+#if 1 //BUILDFLAG(IS_MAC)
     {'B', kCommandKey, "ToggleBold"},
     {'I', kCommandKey, "ToggleItalic"},
 #else
@@ -167,20 +167,40 @@ const KeyboardCodeKeyDownEntry kKeyboardCodeKeyDownEntries[] = {
 #if !BUILDFLAG(IS_MAC)
     // On OS X, we pipe these back to the browser, so that it can do menu item
     // blinking.
-    {'C', kCtrlKey, "Copy"},
-    {'V', kCtrlKey, "Paste"},
-    {'V', kCtrlKey | kShiftKey, "PasteAndMatchStyle"},
-    {'X', kCtrlKey, "Cut"},
-    {'A', kCtrlKey, "SelectAll"},
-    {'Z', kCtrlKey, "Undo"},
-    {'Z', kCtrlKey | kShiftKey, "Redo"},
-    {'Y', kCtrlKey, "Redo"},
+    {'C', kMetaKey, "Copy"},
+    {'V', kMetaKey, "Paste"},
+    {'V', kMetaKey | kShiftKey, "PasteAndMatchStyle"},
+    {'X', kMetaKey, "Cut"},
+    {'A', kMetaKey, "SelectAll"},
+    {'Z', kMetaKey, "Undo"},
+    {'Z', kMetaKey | kShiftKey, "Redo"},
+    {'Y', kMetaKey, "Redo"},
 #endif
 #if BUILDFLAG(IS_WIN)
     {VKEY_BACK, kAltKey, "Undo"},
     {VKEY_BACK, kAltKey | kShiftKey, "Redo"},
 #endif
     {VKEY_INSERT, 0, "OverWrite"},
+    // The following shortcuts are applicable for only for Mac client. In actual mac
+    // platform, these shortcuts will be handled automatically by Apple's AppKit
+    {VKEY_LEFT, kMetaKey, "MoveToBeginningOfLine"},
+    {VKEY_LEFT, kMetaKey | kShiftKey, "MoveToBeginningOfLineAndModifySelection"},
+    {VKEY_RIGHT, kMetaKey, "MoveToEndOfLine"},
+    {VKEY_RIGHT, kMetaKey | kShiftKey, "MoveToEndOfDocumentAndModifySelection"},
+    {VKEY_UP, kOptionKey, "MoveParagraphBackward"},
+    {VKEY_UP, kOptionKey | kShiftKey, "MoveParagraphBackwardAndModifySelection"},
+    {VKEY_DOWN, kOptionKey, "MoveParagraphForward"},
+    {VKEY_DOWN, kOptionKey | kShiftKey, "MoveParagraphForwardAndModifySelection"},
+    {VKEY_UP, kMetaKey, "MoveToBeginningOfDocument"},
+    {VKEY_UP, kMetaKey | kShiftKey, "MoveToBeginningOfDocumentAndModifySelection"},
+    {VKEY_DOWN, kMetaKey, "MoveToEndOfDocument"},
+    {VKEY_DOWN, kMetaKey | kShiftKey, "MoveToEndOfDocumentAndModifySelection"},
+    {'H', kCtrlKey, "DeleteBackward"},
+    {'D', kCtrlKey, "DeleteForward"},
+    {'B', kCtrlKey, "MoveLeft"},
+    {'F', kCtrlKey, "MoveRight"},
+    {'P', kCtrlKey, "MoveUp"},
+    {'N', kCtrlKey, "MoveDown"},
 };
 
 const KeyboardCodeKeyPressEntry kKeyboardCodeKeyPressEntries[] = {
diff --git a/third_party/blink/renderer/core/exported/web_plugin_container_impl.cc b/third_party/blink/renderer/core/exported/web_plugin_container_impl.cc
index 27fbc0f8b7ec4..52d984f3a2c44 100644
--- a/third_party/blink/renderer/core/exported/web_plugin_container_impl.cc
+++ b/third_party/blink/renderer/core/exported/web_plugin_container_impl.cc
@@ -111,7 +111,7 @@ namespace blink {
 
 namespace {
 
-#if BUILDFLAG(IS_MAC)
+#if 1 //BUILDFLAG(IS_MAC)
 const WebInputEvent::Modifiers kEditingModifier = WebInputEvent::kMetaKey;
 #else
 const WebInputEvent::Modifiers kEditingModifier = WebInputEvent::kControlKey;
diff --git a/ui/base/accelerators/accelerator.cc b/ui/base/accelerators/accelerator.cc
index 2468b2c588182..e8d2981ff7298 100644
--- a/ui/base/accelerators/accelerator.cc
+++ b/ui/base/accelerators/accelerator.cc
@@ -205,7 +205,7 @@ bool Accelerator::IsShiftDown() const {
 }
 
 bool Accelerator::IsCtrlDown() const {
-  return (modifiers_ & EF_CONTROL_DOWN) != 0;
+  return (modifiers_ & EF_COMMAND_DOWN) != 0;
 }
 
 bool Accelerator::IsAltDown() const {
@@ -217,7 +217,7 @@ bool Accelerator::IsAltGrDown() const {
 }
 
 bool Accelerator::IsCmdDown() const {
-  return (modifiers_ & EF_COMMAND_DOWN) != 0;
+  return (modifiers_ & EF_CONTROL_DOWN) != 0;
 }
 
 bool Accelerator::IsFunctionDown() const {
diff --git a/ui/events/event.h b/ui/events/event.h
index ae5e40ab11e0c..d67a6eda2606e 100644
--- a/ui/events/event.h
+++ b/ui/events/event.h
@@ -117,9 +117,9 @@ class EVENTS_EXPORT Event {
   // The following methods return true if the respective keys were pressed at
   // the time the event was created.
   bool IsShiftDown() const { return (flags_ & EF_SHIFT_DOWN) != 0; }
-  bool IsControlDown() const { return (flags_ & EF_CONTROL_DOWN) != 0; }
+  bool IsControlDown() const { return (flags_ & EF_COMMAND_DOWN) != 0; }
   bool IsAltDown() const { return (flags_ & EF_ALT_DOWN) != 0; }
-  bool IsCommandDown() const { return (flags_ & EF_COMMAND_DOWN) != 0; }
+  bool IsCommandDown() const { return (flags_ & EF_CONTROL_DOWN) != 0; }
   bool IsAltGrDown() const { return (flags_ & EF_ALTGR_DOWN) != 0; }
   bool IsCapsLockOn() const { return (flags_ & EF_CAPS_LOCK_ON) != 0; }
 
diff --git a/ui/events/event_constants.h b/ui/events/event_constants.h
index c16556cd8c1d8..04c1dd9ee1568 100644
--- a/ui/events/event_constants.h
+++ b/ui/events/event_constants.h
@@ -49,7 +49,7 @@ enum EventFlags {
 // An artificial value used to bridge platform differences.
 // Many commands on Mac as Cmd+Key are the counterparts of
 // Ctrl+Key on other platforms.
-#if BUILDFLAG(IS_APPLE)
+#if 1 //BUILDFLAG(IS_APPLE)
   EF_PLATFORM_ACCELERATOR = EF_COMMAND_DOWN,
 #else
   EF_PLATFORM_ACCELERATOR = EF_CONTROL_DOWN,
diff --git a/ui/views/controls/textfield/textfield.cc b/ui/views/controls/textfield/textfield.cc
index ad0c697c839e0..62f84dd9e7a01 100644
--- a/ui/views/controls/textfield/textfield.cc
+++ b/ui/views/controls/textfield/textfield.cc
@@ -249,9 +249,9 @@ Textfield::Textfield()
   // These allow BrowserView to pass edit commands from the Chrome menu to us
   // when we're focused by simply asking the FocusManager to
   // ProcessAccelerator() with the relevant accelerators.
-  AddAccelerator(ui::Accelerator(ui::VKEY_X, ui::EF_CONTROL_DOWN));
-  AddAccelerator(ui::Accelerator(ui::VKEY_C, ui::EF_CONTROL_DOWN));
-  AddAccelerator(ui::Accelerator(ui::VKEY_V, ui::EF_CONTROL_DOWN));
+  AddAccelerator(ui::Accelerator(ui::VKEY_X, ui::EF_COMMAND_DOWN));
+  AddAccelerator(ui::Accelerator(ui::VKEY_C, ui::EF_COMMAND_DOWN));
+  AddAccelerator(ui::Accelerator(ui::VKEY_V, ui::EF_COMMAND_DOWN));
 #endif
 
   // Sometimes there are additional ignored views, such as the View representing
