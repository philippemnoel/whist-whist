// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const findMandelboxesForUserSQL = `SELECT * FROM hardware.mandelbox_info
  WHERE instance_name = $1
    AND user_id = $2;`

type FindMandelboxesForUserRow struct {
	MandelboxID           pgtype.Varchar `json:"mandelbox_id"`
	UserID                pgtype.Varchar `json:"user_id"`
	InstanceName          pgtype.Varchar `json:"instance_name"`
	Status                pgtype.Varchar `json:"status"`
	CreationTimeUtcUnixMs int            `json:"creation_time_utc_unix_ms"`
}

// FindMandelboxesForUser implements Querier.FindMandelboxesForUser.
func (q *DBQuerier) FindMandelboxesForUser(ctx context.Context, instanceName string, userID string) ([]FindMandelboxesForUserRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindMandelboxesForUser")
	rows, err := q.conn.Query(ctx, findMandelboxesForUserSQL, instanceName, userID)
	if err != nil {
		return nil, fmt.Errorf("query FindMandelboxesForUser: %w", err)
	}
	defer rows.Close()
	items := []FindMandelboxesForUserRow{}
	for rows.Next() {
		var item FindMandelboxesForUserRow
		if err := rows.Scan(&item.MandelboxID, &item.UserID, &item.InstanceName, &item.Status, &item.CreationTimeUtcUnixMs); err != nil {
			return nil, fmt.Errorf("scan FindMandelboxesForUser row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindMandelboxesForUser rows: %w", err)
	}
	return items, err
}

// FindMandelboxesForUserBatch implements Querier.FindMandelboxesForUserBatch.
func (q *DBQuerier) FindMandelboxesForUserBatch(batch *pgx.Batch, instanceName string, userID string) {
	batch.Queue(findMandelboxesForUserSQL, instanceName, userID)
}

// FindMandelboxesForUserScan implements Querier.FindMandelboxesForUserScan.
func (q *DBQuerier) FindMandelboxesForUserScan(results pgx.BatchResults) ([]FindMandelboxesForUserRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindMandelboxesForUserBatch: %w", err)
	}
	defer rows.Close()
	items := []FindMandelboxesForUserRow{}
	for rows.Next() {
		var item FindMandelboxesForUserRow
		if err := rows.Scan(&item.MandelboxID, &item.UserID, &item.InstanceName, &item.Status, &item.CreationTimeUtcUnixMs); err != nil {
			return nil, fmt.Errorf("scan FindMandelboxesForUserBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindMandelboxesForUserBatch rows: %w", err)
	}
	return items, err
}
