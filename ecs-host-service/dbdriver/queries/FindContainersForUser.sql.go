// Code generated by pggen. DO NOT EDIT.

package queries

import (
	"context"
	"fmt"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const findContainersForUserSQL = `SELECT * FROM hardware.container_info
  WHERE instance_name = $1
    AND user_id = $2;`

type FindContainersForUserRow struct {
	ContainerID           pgtype.Varchar `json:"container_id"`
	UserID                pgtype.Varchar `json:"user_id"`
	InstanceName          pgtype.Varchar `json:"instance_name"`
	Status                pgtype.Varchar `json:"status"`
	CreationTimeUtcUnixMs int            `json:"creation_time_utc_unix_ms"`
}

// FindContainersForUser implements Querier.FindContainersForUser.
func (q *DBQuerier) FindContainersForUser(ctx context.Context, instanceName string, userID string) ([]FindContainersForUserRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "FindContainersForUser")
	rows, err := q.conn.Query(ctx, findContainersForUserSQL, instanceName, userID)
	if err != nil {
		return nil, fmt.Errorf("query FindContainersForUser: %w", err)
	}
	defer rows.Close()
	items := []FindContainersForUserRow{}
	for rows.Next() {
		var item FindContainersForUserRow
		if err := rows.Scan(&item.ContainerID, &item.UserID, &item.InstanceName, &item.Status, &item.CreationTimeUtcUnixMs); err != nil {
			return nil, fmt.Errorf("scan FindContainersForUser row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindContainersForUser rows: %w", err)
	}
	return items, err
}

// FindContainersForUserBatch implements Querier.FindContainersForUserBatch.
func (q *DBQuerier) FindContainersForUserBatch(batch *pgx.Batch, instanceName string, userID string) {
	batch.Queue(findContainersForUserSQL, instanceName, userID)
}

// FindContainersForUserScan implements Querier.FindContainersForUserScan.
func (q *DBQuerier) FindContainersForUserScan(results pgx.BatchResults) ([]FindContainersForUserRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query FindContainersForUserBatch: %w", err)
	}
	defer rows.Close()
	items := []FindContainersForUserRow{}
	for rows.Next() {
		var item FindContainersForUserRow
		if err := rows.Scan(&item.ContainerID, &item.UserID, &item.InstanceName, &item.Status, &item.CreationTimeUtcUnixMs); err != nil {
			return nil, fmt.Errorf("scan FindContainersForUserBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close FindContainersForUserBatch rows: %w", err)
	}
	return items, err
}
