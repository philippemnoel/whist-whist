# Go parameters
GOCMD        = go
GOBUILD      = $(GOCMD) build
GORUN        = $(GOCMD) run
GOCLEAN      = $(GOCMD) clean
GOTEST       = $(GOCMD) test
GOGET        = $(GOCMD) get

# Build parameters
BUILD_FOLDER = build
BINARY_NAME  = ecs-host-service

# Git parameters
GIT_COMMIT := $(shell git rev-list -1 HEAD)

# Continuous Integration parameters
CI ?= false
WEBSERVER_AUTH_SECRET_DEV ?= testwebserverauthsecretdev
WEBSERVER_AUTH_SECRET_STAGING ?= testwebserverauthsecretstaging
WEBSERVER_AUTH_SECRET_PROD ?= testwebserverauthsecretprod


all: build

# Check that the required environment variables for building as part of our
# continuous integration/deployment pipeline on GitHub Actions are set properly.
checkCI:
	$(info building in $(BUILD_FOLDER) with CI set to $(CI)...)
ifeq ($(CI),true)
	# We're building on GitHub Actions, so we need to require non-trivial secrets
	$(info CI is true)
ifeq ($(origin WEBSERVER_AUTH_SECRET_DEV),file)
	# This means that a replacement secret was not passed in on the command-line or as an environment variable
	$(error "WEBSERVER_AUTH_SECRET_DEV is not set, but CI is true")
endif
ifeq ($(WEBSERVER_AUTH_SECRET_DEV),)
	$(error "WEBSERVER_AUTH_SECRET_DEV is empty, but CI is true")
endif
ifeq ($(origin WEBSERVER_AUTH_SECRET_STAGING),file)
	$(error "WEBSERVER_AUTH_SECRET_STAGING is not set, but CI is true")
endif
ifeq ($(WEBSERVER_AUTH_SECRET_STAGING),)
	$(error "WEBSERVER_AUTH_SECRET_STAGING is empty, but CI is true")
endif
ifeq ($(origin WEBSERVER_AUTH_SECRET_PROD),file)
	$(error "WEBSERVER_AUTH_SECRET_PROD is not set, but CI is true")
endif
ifeq ($(WEBSERVER_AUTH_SECRET_PROD),)
	$(error "WEBSERVER_AUTH_SECRET_PROD is empty, but CI is true")
endif
else
	$(info CI is false)
endif

build: checkCI
	GOPRIVATE=github.com/fractal/ecs-agent $(GOGET) -d github.com/fractal/ecs-agent/agent@dev
	GOPRIVATE=github.com/fractal/uinput-go $(GOGET) -d github.com/fractal/uinput-go/@master
	go mod tidy
	$(GOBUILD) -ldflags "\
		-X 'github.com/fractal/fractal/ecs-host-service/fractallogger.gitCommit=$(GIT_COMMIT)'\
		-X 'github.com/fractal/fractal/ecs-host-service/httpserver.webserverAuthSecretDev=$(WEBSERVER_AUTH_SECRET_DEV)'\
		-X 'github.com/fractal/fractal/ecs-host-service/httpserver.webserverAuthSecretStaging=$(WEBSERVER_AUTH_SECRET_STAGING)'\
		-X 'github.com/fractal/fractal/ecs-host-service/httpserver.webserverAuthSecretProd=$(WEBSERVER_AUTH_SECRET_PROD)'\
		" -o $(BUILD_FOLDER)/$(BINARY_NAME) ecs-host-service.go

format:
	(cd ~ && $(GOGET) -u golang.org/x/tools/cmd/goimports)
	goimports -l -w $$(find $(CURDIR) -name "*.go" | xargs)

lint:
	(cd ~ && $(GOGET) -u golang.org/x/lint/golint)
	golint ./...

clean:
	$(GOCLEAN)
	rm -rf $(BUILD_FOLDER)

run: build
	$(info running $(BUILD_FOLDER)/$(BINARY_NAME) with local dev (debug) configuration...)
	# we run the built binary instead of using `go run` because otherwise signal
	# handling for Ctrl+C does not work
	sudo env PATH=$(PATH) APP_ENV=localdev $(BUILD_FOLDER)/$(BINARY_NAME)

rundev: build
	$(info running $(BUILD_FOLDER)/$(BINARY_NAME) with dev configuration...)
	sudo env PATH=$(PATH) APP_ENV=development $(BUILD_FOLDER)/$(BINARY_NAME)

runstaging: build
	$(info running $(BUILD_FOLDER)/$(BINARY_NAME) with staging configuration...)
	sudo env PATH=$(PATH) APP_ENV=staging $(BUILD_FOLDER)/$(BINARY_NAME)

runprod: build
	$(info running $(BUILD_FOLDER)/$(BINARY_NAME) with production configuration...)
	sudo env PATH=$(PATH) USE_PROD_SENTRY=1 APP_ENV=production $(BUILD_FOLDER)/$(BINARY_NAME)

.PHONY: build clean run runprod
