/**
 * Copyright (c) 2021-2022 Whist Technologies, Inc.
 * @file clipboard.c
 * @brief This file contains the general clipboard functions for a shared
 *        client-server clipboard.
============================
Usage
============================

GET_OS_CLIPBOARD and SET_OS_CLIPBOARD will return strings representing directories
important for getting and setting file clipboards. When get_os_clipboard() is called
and it returns a CLIPBOARD_FILES type, then GET_OS_CLIPBOARD will be filled with
symlinks to the clipboard files. When set_os_clipboard(cb) is called and is given a
clipboard with a CLIPBOARD_FILES type, then the clipboard will be set to
whatever files are in the SET_OS_CLIPBOARD directory.

LGET_OS_CLIPBOARD and LSET_OS_CLIPBOARD are the wide-character versions of these
strings, for use on windows OS's
*/

/*
============================
Includes
============================
*/

#include "clipboard.h"
#include <whist/core/whist.h>
#include "clipboard_internal.h"

// A Mutex to ensure unsafe commands don't overlap
static WhistMutex clipboard_mutex;
// Whether to send the local clipboard contents on startup
static bool preserve_local_clipboard = false;
// Whether to skip the synchronization for the next clipboard update
//     This is to prevent Peer 2 from sending a copy event back to
//     Peer 1 when Peer 1 sends an updated clipboard to Peer 2
static bool skip_next_has_updated = false;

/*
============================
Public Function Implementations
============================
*/

void init_clipboard(bool is_client) {
    /*
        Intialize clipboard

        Arguments:
            is_client (bool): true if client, false if server.
    */

    if (clipboard_mutex) {
        LOG_ERROR("Clipboard is being initialized twice!");
        return;
    }
    // If the caller is the client, then the clipboard state
    //     should be preserved for the shared clipboard state.
    preserve_local_clipboard = is_client;
    clipboard_mutex = whist_create_mutex();
    unsafe_init_clipboard();
}

bool should_preserve_local_clipboard(void) {
    /*
        Returns whether the local clipboard should be preserved.
        The client should preserve its local clipboard by sharing
        the current clipboard state with the server. The server
        should not preserve its local clipboard state.

        Returns:
            true if client, false if server
    */

    return preserve_local_clipboard;
}

ClipboardData* get_os_clipboard(void) {
    /*
        Get the current OS clipboard data

        Returns:
            (ClipboardData*): Pointer to the current clipboard data as a
                ClipboardData struct

        NOTE: `free_clipboard_buffer` is the function to use to free the space
            allocated for the pulled clipboard in this function
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return NULL;
    }

    whist_lock_mutex(clipboard_mutex);
    ClipboardData* cb = unsafe_get_os_clipboard();
    whist_unlock_mutex(clipboard_mutex);
    return cb;
}

void set_os_clipboard(ClipboardData* cb) {
    /*
        Set the OS clipboard to the given clipboard data

        Arguments:
            cb (ClipboardData*): Pointer to a clipboard data struct to set the
                clipboard to
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return;
    }

    whist_lock_mutex(clipboard_mutex);
    unsafe_set_os_clipboard(cb);
    // Can't clear out update from filling clipboard here
    //     because X11 might not send the event fast enough, causing
    //     a send-back. We set this flag instead.
    skip_next_has_updated = true;
    whist_unlock_mutex(clipboard_mutex);
}

void free_clipboard_buffer(ClipboardData* cb) {
    /*
        Frees a ClipboardData buffer that was generated by get_os_clipboard

        Arguments:
            cb (ClipboardData*): The clipboard to free
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return;
    }

    whist_lock_mutex(clipboard_mutex);
    unsafe_free_clipboard_buffer(cb);
    whist_unlock_mutex(clipboard_mutex);
}

bool has_os_clipboard_updated(void) {
    /*
        Check whether the clipboard has new data

        Returns:
            (bool): true if new clipboard data, false if else
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return false;
    }

    if (whist_try_lock_mutex(clipboard_mutex) == 0) {
        bool has_os_clipboard_updated = unsafe_has_os_clipboard_updated();
        // After setting, we don't want to propagate the next update
        //     because it will just play back the set
        if (has_os_clipboard_updated && skip_next_has_updated) {
            has_os_clipboard_updated = false;
            skip_next_has_updated = false;
        }
        whist_unlock_mutex(clipboard_mutex);
        return has_os_clipboard_updated;
    } else {
        return false;
    }
}

void destroy_clipboard(void) {
    /*
        Destroy current clipboard
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return;
    }

    whist_lock_mutex(clipboard_mutex);
    unsafe_destroy_clipboard();
    whist_unlock_mutex(clipboard_mutex);

    whist_destroy_mutex(clipboard_mutex);
    clipboard_mutex = NULL;
}
