/**
 * Copyright 2021 Fractal Computers, Inc., dba Whist
 * @file clipboard.c
 * @brief This file contains the general clipboard functions for a shared
 *        client-server clipboard.
============================
Usage
============================

GET_CLIPBOARD and SET_CLIPBOARD will return strings representing directories
important for getting and setting file clipboards. When GetClipboard() is called
and it returns a CLIPBOARD_FILES type, then GET_CLIPBOARD will be filled with
symlinks to the clipboard files. When SetClipboard(cb) is called and is given a
clipboard with a CLIPBOARD_FILES type, then the clipboard will be set to
whatever files are in the SET_CLIPBOARD directory.

LGET_CLIPBOARD and LSET_CLIPBOARD are the wide-character versions of these
strings, for use on windows OS's
*/

/*
============================
Includes
============================
*/

#include "clipboard.h"
#include <fractal/core/fractal.h>

// A Mutex to ensure unsafe commands don't overlap
FractalMutex clipboard_mutex;
// Whether to send the local clipboard contents on startup
bool preserve_local_clipboard = false;
// Whether to skip the synchronization for the next clipboard update
//     This is to prevent Peer 2 from sending a copy event back to
//     Peer 1 when Peer 1 sends an updated clipboard to Peer 2
bool skip_next_has_updated = false;

/*
============================
Private Functions
============================
*/

// These clipboard primitives are defined in {x11,win,mac}_clipboard.c
// CMake will only link one of those C files, depending on the OS

void unsafe_init_clipboard();
ClipboardData* unsafe_get_clipboard();
void unsafe_set_clipboard(ClipboardData* cb);
void unsafe_free_clipboard(ClipboardData* cb);
bool unsafe_has_clipboard_updated();
void unsafe_destroy_clipboard();

/*
============================
Public Function Implementations
============================
*/

void init_clipboard(bool is_client) {
    /*
        Intialize clipboard

        Arguments:
            is_client (bool): true if client, false if server.
    */

    if (clipboard_mutex) {
        LOG_ERROR("Clipboard is being initialized twice!");
        return;
    }
    // If the caller is the client, then the clipboard state
    //     should be preserved for the shared clipboard state.
    preserve_local_clipboard = is_client;
    clipboard_mutex = fractal_create_mutex();
    unsafe_init_clipboard();
}

bool should_preserve_local_clipboard() {
    /*
        Returns whether the local clipboard should be preserved.
        The client should preserve its local clipboard by sharing
        the current clipboard state with the server. The server
        should not preserve its local clipboard state.

        Returns:
            true if client, false if server
    */

    return preserve_local_clipboard;
}

ClipboardData* get_clipboard() {
    /*
        Get the current clipboard data

        Returns:
            (ClipboardData*): Pointer to the current clipboard data as a
                ClipboardData struct
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return NULL;
    }

    fractal_lock_mutex(clipboard_mutex);
    ClipboardData* cb = unsafe_get_clipboard();
    fractal_unlock_mutex(clipboard_mutex);
    return cb;
}

void set_clipboard(ClipboardData* cb) {
    /*
        Set the clipboard to the given clipboard data

        Arguments:
            cb (ClipboardData*): Pointer to a clipboard data struct to set the
                clipboard to
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return;
    }

    fractal_lock_mutex(clipboard_mutex);
    unsafe_set_clipboard(cb);
    // Can't clear out update from filling clipboard here
    //     because X11 might not send the event fast enough, causing
    //     a send-back. We set this flag instead.
    skip_next_has_updated = true;
    fractal_unlock_mutex(clipboard_mutex);
}

void free_clipboard(ClipboardData* cb) {
    /*
        Frees a Clipboard that was generated by get_clipboard

        Arguments:
            cb (ClipboardData*): The clipboard to free
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return;
    }

    fractal_lock_mutex(clipboard_mutex);
    unsafe_free_clipboard(cb);
    fractal_unlock_mutex(clipboard_mutex);
}

bool has_clipboard_updated() {
    /*
        Check whether the clipboard has new data

        Returns:
            (bool): true if new clipboard data, false if else
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return false;
    }

    if (fractal_try_lock_mutex(clipboard_mutex) == 0) {
        bool has_clipboard_updated = unsafe_has_clipboard_updated();
        // After setting, we don't want to propagate the next update
        //     because it will just play back the set
        if (has_clipboard_updated && skip_next_has_updated) {
            has_clipboard_updated = false;
            skip_next_has_updated = false;
        }
        fractal_unlock_mutex(clipboard_mutex);
        return has_clipboard_updated;
    } else {
        return false;
    }
}

void destroy_clipboard() {
    /*
        Destroy current clipboard
    */

    if (!clipboard_mutex) {
        LOG_ERROR("init_clipboard not called yet!");
        return;
    }

    fractal_lock_mutex(clipboard_mutex);
    unsafe_destroy_clipboard();
    fractal_unlock_mutex(clipboard_mutex);

    fractal_destroy_mutex(clipboard_mutex);
    clipboard_mutex = NULL;
}
