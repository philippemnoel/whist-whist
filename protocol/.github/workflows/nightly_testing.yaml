# Run streaming tests between Azure (server) and GitHub VMs (client) every night

name: Nightly testing
# Run every day at 6 am UTC, 2am eastern
on:
  schedule:
    - cron:  '0 6 * * *'

#on: [push] for debugging workflow

env:
  CMAKE_VERSION: 3.15.7
  NINJA_VERSION: 1.9.0
  BUILD_TYPE: Debug
  CCACHE_VERSION: 3.7.7
  SERVER_VM_NAME: crimsonbonus543
  SERVER_VM_IP: 20.185.40.33
  WEBSERVER_BASE_URL: https://cube-celery-staging4.herokuapp.com
  BRANCH_NAME: hamish-gh-run # branch on which the scheduled tests are run, change to dev before merging pr

jobs:
  build:
    name: ${{ matrix.config.name }}
    runs-on: ${{ matrix.config.os }}
    strategy:
      fail-fast: false
      matrix:
        config:
          - {
            name: "Windows Latest MSVC", artifact: "Windows-MSVC.tar.xz",
            os: windows-latest,
            cc: "cl", cxx: "cl",
            environment_script: "C:/Program Files (x86)/Microsoft Visual Studio/2019/Enterprise/VC/Auxiliary/Build/vcvars64.bat"
          }
          - {
            name: "Ubuntu Latest GCC", artifact: "Linux.tar.xz",
            os: ubuntu-latest,
            cc: "gcc", cxx: "g++"
          }
          - {
            name: "macOS Latest Clang", artifact: "macOS.tar.xz",
            os: macos-latest,
            cc: "clang", cxx: "clang++"
          }

    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{ secrets.BRANCH_NIGHTLY_CI }}
      - name: Download Ninja and CMake, install linux dependencies + linux cppcheck
        id: cmake_and_ninja
        shell: cmake -P {0}
        run: |
          set(cmake_version $ENV{CMAKE_VERSION})
          set(ninja_version $ENV{NINJA_VERSION})
          message(STATUS "Using host CMake version: ${CMAKE_VERSION}")

          if ("${{ runner.os }}" STREQUAL "Windows")
            set(ninja_suffix "win.zip")
            set(cmake_suffix "win64-x64.zip")
            set(cmake_dir "cmake-${cmake_version}-win64-x64/bin")
            message(STATUS "\n ::add-matcher::${{ github.workspace }}\.github\msvc_matcher.json\n")
            message(STATUS "\n ::add-matcher::${{ github.workspace }}\.github\msvc_linker_matcher.json\n")
          elseif ("${{ runner.os }}" STREQUAL "Linux")
            set(ninja_suffix "linux.zip")
            set(cmake_suffix "Linux-x86_64.tar.gz")
            set(cmake_dir "cmake-${cmake_version}-Linux-x86_64/bin")
            message(STATUS "\n ::add-matcher::${{ github.workspace }}/.github/gcc_matcher.json\n")
          elseif ("${{ runner.os }}" STREQUAL "macOS")
            set(ninja_suffix "mac.zip")
            set(cmake_suffix "Darwin-x86_64.tar.gz")
            set(cmake_dir "cmake-${cmake_version}-Darwin-x86_64/CMake.app/Contents/bin")
            message(STATUS "\n ::add-matcher::${{ github.workspace }}/.github/clang_matcher.json\n")
          endif()

          set(ninja_url "https://github.com/ninja-build/ninja/releases/download/v${ninja_version}/ninja-${ninja_suffix}")
          file(DOWNLOAD "${ninja_url}" ./ninja.zip SHOW_PROGRESS)
          execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ./ninja.zip)

          set(cmake_url "https://github.com/Kitware/CMake/releases/download/v${cmake_version}/cmake-${cmake_version}-${cmake_suffix}")
          file(DOWNLOAD "${cmake_url}" ./cmake.zip SHOW_PROGRESS)
          execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ./cmake.zip)

          # Save the path for other steps
          file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}/${cmake_dir}" cmake_dir)
          message("::set-output name=cmake_dir::${cmake_dir}")

          if (NOT "${{ runner.os }}" STREQUAL "Windows")

            execute_process(
              COMMAND chmod +x ninja
              COMMAND chmod +x ${cmake_dir}/cmake
            )
          endif()

          message(STATUS "\n::add-matcher::./.github/cppcheck_matcher.json\n")
          message(STATUS "\n::add-matcher::./.github/cmake_matcher.json\n")

          if ("${{ runner.os }}" STREQUAL "Linux")
            # install linux dev dependencies
              execute_process(COMMAND ${{ github.workspace }}/desktop/linux-client-setup.sh)
              execute_process(COMMAND bash -c "sudo apt-get install cppcheck -y")
          elseif("${{ runner.os }}" STREQUAL "macOS")
              execute_process(COMMAND brew install cppcheck)
          endif()

      - name: Download ccache
        id: ccache
        shell: cmake -P {0}
        run: |
          set(ccache_url "https://github.com/cristianadam/ccache/releases/download/v$ENV{CCACHE_VERSION}/${{ runner.os }}.tar.xz")
          file(DOWNLOAD "${ccache_url}" ./ccache.tar.xz SHOW_PROGRESS)
          execute_process(COMMAND ${CMAKE_COMMAND} -E tar xvf ./ccache.tar.xz)

      - name: Prepare ccache timestamp
        id: ccache_cache_timestamp
        shell: cmake -P {0}
        run: |
          string(TIMESTAMP current_date "%Y-%m-%d-%H;%M;%S" UTC)
          message("::set-output name=timestamp::${current_date}")

      - name: ccache cache files
        uses: actions/cache@v1.1.0
        with:
          path: .ccache
          key: ${{ matrix.config.name }}-ccache-${{ steps.ccache_cache_timestamp.outputs.timestamp }}
          restore-keys: |
            ${{ matrix.config.name }}-ccache-

      - name: Configure
        shell: cmake -P {0}
        run: |
          set(ENV{CC} ${{ matrix.config.cc }})
          set(ENV{CXX} ${{ matrix.config.cxx }})

          if ("${{ runner.os }}" STREQUAL "Windows" AND NOT "x${{ matrix.config.environment_script }}" STREQUAL "x")
            execute_process(
              COMMAND "${{ matrix.config.environment_script }}" && set
              OUTPUT_FILE environment_script_output.txt
            )
            file(STRINGS environment_script_output.txt output_lines)
            foreach(line IN LISTS output_lines)
              if (line MATCHES "^([a-zA-Z0-9_-]+)=(.*)$")
                set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
              endif()
            endforeach()
          endif()

          set(path_separator ":")
          if ("${{ runner.os }}" STREQUAL "Windows")
            set(path_separator ";")
          endif()
          set(ENV{PATH} "$ENV{GITHUB_WORKSPACE}${path_separator}$ENV{PATH}")

          execute_process(
            COMMAND ${{ steps.cmake_and_ninja.outputs.cmake_dir }}/cmake
              -S .
              -B build
              -D CMAKE_BUILD_TYPE=$ENV{BUILD_TYPE}
              -G Ninja
              -D CMAKE_MAKE_PROGRAM=ninja
              -D CMAKE_C_COMPILER_LAUNCHER=ccache
              -D CMAKE_CXX_COMPILER_LAUNCHER=ccache
              -D CMAKE_OSX_SYSROOT=/Applications/Xcode_10.3.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk
              -DUSE_CPPCHECK=ON
              -DCMAKE_BUILD_TYPE=Release
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

      - name: Build
        shell: cmake -P {0}
        run: |
          set(ENV{NINJA_STATUS} "[%f/%t %o/sec] ")

          if ("${{ runner.os }}" STREQUAL "Windows" AND NOT "x${{ matrix.config.environment_script }}" STREQUAL "x")
            file(STRINGS environment_script_output.txt output_lines)
            foreach(line IN LISTS output_lines)
              if (line MATCHES "^([a-zA-Z0-9_-]+)=(.*)$")
                set(ENV{${CMAKE_MATCH_1}} "${CMAKE_MATCH_2}")
              endif()
            endforeach()
          endif()

          set(path_separator ":")
          if ("${{ runner.os }}" STREQUAL "Windows")
            set(path_separator ";")
          endif()
          set(ENV{PATH} "$ENV{GITHUB_WORKSPACE}${path_separator}$ENV{PATH}")

          file(TO_CMAKE_PATH "$ENV{GITHUB_WORKSPACE}" ccache_basedir)
          set(ENV{CCACHE_BASEDIR} "${ccache_basedir}")
          set(ENV{CCACHE_DIR} "${ccache_basedir}/.ccache")
          set(ENV{CCACHE_COMPRESS} "true")
          set(ENV{CCACHE_COMPRESSLEVEL} "6")
          set(ENV{CCACHE_MAXSIZE} "400M")
          if ("${{ matrix.config.cxx }}" STREQUAL "cl")
            set(ENV{CCACHE_MAXSIZE} "600M")
          endif()

          execute_process(COMMAND ccache -p)
          execute_process(COMMAND ccache -z)

          execute_process(
            COMMAND ${{ steps.cmake_and_ninja.outputs.cmake_dir }}/cmake --build build
            RESULT_VARIABLE result
          )
          if (NOT result EQUAL 0)
            message(FATAL_ERROR "Bad exit status")
          endif()

          execute_process(COMMAND ccache -s)
      - name: Upload windows server artifact.
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v2
        with:
          name: windows_server_build
          path: ${{ github.workspace }}/server/build64
      - name: Upload windows client artifact.
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v2
        with:
          name: windows_client_build
          path: ${{ github.workspace }}/desktop/build64/Windows
      - name: Upload ubuntu client artifact.
        if: runner.os == 'Linux'
        uses: actions/upload-artifact@v2
        with:
          name: linux_client_build
          path: ${{ github.workspace }}/desktop/build64/Linux
      - name: Upload mac client artifact.
        if: runner.os == 'macOS'
        uses: actions/upload-artifact@v2
        with:
          name: mac_client_build
          path: ${{ github.workspace }}/desktop/build64/Darwin

  start_vm:
    name: start_vm
    runs-on: ubuntu-18.04
    steps:
      - name: startup_vm
        run: |
          curl -X POST -H Content-Type:application/json  -d "{
          \"vm_name\" : \"$SERVER_VM_NAME\",
          \"resource_group\" : \"FractalProtocolCI\" }" \
          $WEBSERVER_BASE_URL/azure_vm/start
          sleep 500s

  deploy_to_vm:
    name: deploy_vm
    runs-on: ubuntu-18.04
    needs: [build, start_vm]
    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{ secrets.BRANCH_NIGHTLY_CI }}
      - name: deploy to VM
        run: |
          cd ${{ github.workspace }}/.github/
          ./deploy_artifact.sh $SERVER_VM_NAME ${{github.run_id}} --webserver $WEBSERVER_BASE_URL
          sleep 300s

  test_linux:
    name: test_ubuntu_18.04
    runs-on: ubuntu-18.04
    needs: deploy_to_vm
    steps:
      - name: get linux build
        uses: actions/download-artifact@v1
        with:
          name: linux_client_build
      - name: get linux deps
        run: |
          sudo apt-get install valgrind pulseaudio jackd2 alsa-utils dbus-x11 libavcodec-dev libavdevice-dev libx11-dev libxtst-dev xclip x11-xserver-utils libasound2-dev libxdamage-dev -y
      - name: run linux
        if: always()
        run: |
          cd linux_client_build && chmod +x FractalClient
          sleep 1
          xvfb-run ./FractalClient -k $SERVER_VM_IP | tee log.txt
      - name: Upload linux client logs
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: linux_client_log
          path: linux_client_build/log.txt
      - name: run linux valgrind # failing valgrind doesn't count as a failure
        if: always()
        run: |
          sleep 5
          cd linux_client_build && chmod +x FractalClient
          set +e
          xvfb-run valgrind --leak-check=full  \
          --log-file="valgrind.out" --track-origins=yes  ./FractalClient -k $SERVER_VM_IP
          sleep 10
      - name: Upload linux client valgrind logs
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: linux_client_valgrind_log
          path: linux_client_build/valgrind.out

  test_windows:
    if: always() # run even if linux fails
    name: test_windows
    runs-on: windows-2016
    needs: test_linux
    steps:
      - name: get windows build
        uses: actions/download-artifact@v1
        with:
          name: windows_client_build
#      - name: Download
#        run: Invoke-WebRequest https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-windows-amd64.zip -OutFile ngrok.zip
#      - name: Extract
#        run: Expand-Archive ngrok.zip
#      - name: Auth
#        run: .\ngrok\ngrok.exe authtoken $Env:NGROK_AUTH_TOKEN
#        env:
#          NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
#      - name: Enable TS
#        run: Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server'-name "fDenyTSConnections" -Value 0
#      - run: Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
#      - run: Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -name "UserAuthentication" -Value 1
#      - run: Set-LocalUser -Name "runneradmin" -Password (ConvertTo-SecureString -AsPlainText "P@ssw0rd!" -Force)
#      - name: Create Tunnel
#        run: .\ngrok\ngrok.exe tcp 3389
      - name: run Windows
        working-directory: windows_client_build
        run: .\FractalClient -k $Env:SERVER_VM_IP
      - name: logs
        if: always()
        run: |
          cd windows_client_build
          cat log.txt
      - name: Upload Windows client logs
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: windows_client_log
          path: ${{ github.workspace }}/windows_client_build/log.txt

  test_mac:
    if: always() # run even if windows fails
    name: test_osx_10.15
    runs-on: macos-latest
    needs: test_windows
    steps:
      - name: get mac build
        uses: actions/download-artifact@v1
        with:
          name: mac_client_build
      - name: run mac client
        run: |
          sleep 5
          cd mac_client_build
          chmod +x FractalClient
          ./FractalClient -k $SERVER_VM_IP | tee log.txt
          cd
          ls
          cd .fractal
          ls
      - name: Upload mac client logs
        uses: actions/upload-artifact@v2
        if: always()
        with:
          name: mac_client_log
          path: mac_client_build/log.txt

  clean_up:
    if: always() # run always, must turn off the VM when we are done.
    name: clean_up
    runs-on: ubuntu-18.04
    needs: test_mac
    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{ secrets.BRANCH_NIGHTLY_CI }}
      - name: get server logs
        run: |
          chmod 0600 ${{github.workspace}}/.github/sshkey
          sftp -o StrictHostKeyChecking=no  -i ${{github.workspace}}/.github/sshkey Fractal@20.185.40.33:/C:/programdata/fractalcache/log.txt .
      - name: Upload windows server logs
        uses: actions/upload-artifact@v2
        with:
          name: windows_server_log
          path: log.txt
      - name: Stop VM
        if: always() # if we fail to get logs we should still kill the VM when done
        run: |
          curl -X POST -H Content-Type:application/json  -d "{
                    \"vm_name\" : \"$SERVER_VM_NAME\",
                    \"resource_group\" : \"FractalProtocolCI\" }" \
                    $WEBSERVER_BASE_URL/azure_vm/deallocate
